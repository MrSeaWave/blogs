{"pages":[{"title":"About me","text":".heimu { color: #000; background-color: #000; } .heimu:hover { color: #fff; } 95后前端开发一枚，爱好动漫，撸猫， 家有两只猫，一只蒂阿瑞（英短银渐层），一只逢坂大河（狸花猫），旅游，游戏，ps4（Fantasy_FishViy），switch党 独爱魂系游戏，欢迎一起来传火！ 2020年加入 如果青年 和朋友们一起搞事情，哇哈哈哈 博客主要写文章，技术 or 自己还没能解决的坑，但可能因为表述会有点问题，博客更多只是写给自己看的，如果发现不懂之处和可以改进的地方欢迎留言 🙏 本站文章如无特别声明，均为原创，转载请注明来源","link":"/blogs/about/index.html"},{"title":"友人帐","text":"function changeFrameHeight(){ const ifm= document.getElementById(\"blogFriend\"); ifm.height=ifm.contentWindow.document.body.scrollHeight; }; window.onresize=function(){ changeFrameHeight(); }","link":"/blogs/friends/index.html"},{"title":"留言板","text":"不留下点什么证明你来过吗~","link":"/blogs/messages/index.html"}],"posts":[{"title":"修复 CI 构建博客造成的更新时间错误","text":"当使用 Travis CI or Github Actions 自动化部署时，发现部署成功后，所有文章的更新时间都变成了此次提交修改的时间，但有些文章在上一次提交后是没有发生过任何修改的。 这是因为 git 在推送更新时，并不记录保存文件的访问时间、修改时间等元信息，（原因在这里）所以每次使用 git 把项目 clone 下来时，文件的时间都是克隆时的时间。又因为如果没有在 front-matter 中指定 updated，Hexo 会默认使用文件的最后修改时间作为文章的更新时间，所以会出现所有文章的更新时间都发生变化的情况。 总的来说，使用 git clone 下来的文件的时间都不是原来文件的时间，而自动化部署每次都需要 clone 源码才能进行后面的生成和部署操作，所以目前如果想正确显示更新时间。需要： 方法一：使用 updated 属性字段在文章中的front-matter中添加updated: 更新时间项 front-matter12345title: 修复 CI 构建博客造成的更新时间错误author: Seatoc: truedate: 2021-01-07 15:53:16updated: 2021-01-07 15:53:16 以后修改文件的话也只需修改updated项对应日期即可，但是这样有个弊端，完全需要靠自己自觉去修改更新时间，自己一旦忘掉，那么更新时间的意义也就荡然无存了，因此这里推荐第二种方法。 方法二：使用 git 推送时间如果你用的是Travis Ci的话，只需要在.travis.yml添加如下配置： .travis.yml123before_install: # Restore last modified time - 'git ls-files -z | while read -d '''' path; do touch -d &quot;$(git log -1 --format=&quot;@%ct&quot; &quot;$path&quot;)&quot; &quot;$path&quot;; done' 如果你用的是Github Actions的话，只需要在对应的yml添加如下配置： actions123456jobs: &lt;jobs_id&gt;: steps: - name: Restore file modification time run: | &quot;git ls-files -z | while read -d '' path; do touch -d \\&quot;$(git log -1 --format=\\&quot;@%ct\\&quot; \\&quot;$path\\&quot;)\\&quot; \\&quot;$path\\&quot;; done&quot; 当然git ls-files 如果不好用可以改成 find： bash1find source/_posts -name '*.md' | while read file; do touch -d &quot;$(git log -1 --format=&quot;@%ct&quot; &quot;$file&quot;)&quot; &quot;$file&quot;; done 实际上，clone 下来的文件的时间还是克隆时的时间，然后通过上面的命令，它将 clone 下来的文件的时间改成了该文件最近一次变动的推送时间（也即文件最后一次修改的 push 时间）。 注：如果github actions中使用actions/checkout@v2，请设定它的参数fetch-depth: 0，因为0表示获取所有分支和标签的所有历史记录。默认值为1 小知识： bash12345678# 获取 git 仓库中所有文件的最新修改时间git ls-tree -r --name-only HEAD | while read filename; do echo &quot;$(git log -1 --format=&quot;%ad&quot; -- $filename) $filename&quot;done# 获取 git 仓库中所有文件的最初创建时间git ls-tree -r --name-only HEAD | while read filename; do echo &quot;$(git log --format=&quot;%ad&quot; -- $filename | tail -1) $filename&quot;done 参考链接 GIT 获取文件最初创建及最新修改日期 How to retrieve the last modification date of all files in a git repository：介绍了如何获取 git 仓库中，所有文件的最新修改时间。 Finding the date/time a file was first added to a Git repository：介绍了如何获取 git 仓库中，所有文件最初的创建时间。 Hexo 相关问题和优化 The update time of the article is incorrect 修复 CI 构建博客造成的更新时间错误","link":"/blogs/articles/2021/01/07/ci-hexo-update-time/"},{"title":"谷歌浏览器历史版本下载","text":"本文将介绍谷歌浏览器历史版本如何下载及其代码仓库原理介绍。 打开网页 https://mrseawave.github.io/chromium-history-page/ ，选择对应的 OS，与 version 点击进行下载即可。 网页源码：https://github.com/MrSeaWave/chromium-history-page dataSource：https://github.com/MrSeaWave/chromium-history-dataSource crawler(BASE): https://github.com/MrSeaWave/chromium-history-crawler 原理介绍crawler 仓库代码解析 Step_1寻找所有的 version&amp;&amp;version 对应的 position getPositionByVersion1$ node ./src/getPositionByVersion.js versionUrl + versionPositionUrl====&gt;生成 all-version.json, version-position.json versionUrl ：爬虫获取所有 version versionPositionUrl: 通过指定的 version 获取特定的 position all-version.json: all-version.json1234567[ &quot;90.0.4399.1&quot;, &quot;90.0.4399.0&quot;, &quot;90.0.4398.1&quot;, &quot;90.0.4398.0&quot; // ...] version-position.json: version-position.json1234567{ &quot;90.0.4399.1&quot;: &quot;846615&quot;, &quot;90.0.4399.0&quot;: &quot;846615&quot;, &quot;90.0.4398.1&quot;: &quot;846545&quot;, &quot;90.0.4398.0&quot;: &quot;846545&quot; // ...} Step_2寻找不同 os 对应的 position：position/position-Mac.json etc. getPositionWithOsList1$ node ./src/getPositionWithOsList.js positionUrl====&gt;position/position-Mac.json position-Mac.json: position-Mac.json1234567[ &quot;15734&quot;, &quot;15749&quot;, &quot;15839&quot;, &quot;15942&quot; // ...] Step_3结合step_1与step_2的数据生成最终文件：ver-pos-os/version-position-Mac.json verPosOsGen.js1$ node ./src/verPosOsGen version-position.json &amp;&amp; position/position-os.json ===&gt; ver-pos-os/version-position-Mac.json etc. ver-pos-os.json: ver-pos-os.json1234567{ &quot;90.0.4398.1&quot;: &quot;846545&quot;, &quot;90.0.4398.0&quot;: &quot;846545&quot;, &quot;90.0.4396.2&quot;: &quot;845872&quot;, &quot;90.0.4396.1&quot;: &quot;845872&quot; // ...} json stepsjson-steps123all-version.json -&gt; version-position.json -&gt; -&gt; ver-pos-[os].json position-[os].json -&gt; Step_4 数据存储：将上述steps中生成的json文件夹下的数据复制到chromium-history-dataSource仓库中，留作备份。 网页发布：将ver-pos-os/version-position-Mac.json复制到前端代码仓库:chromium-history-page public文件夹下，并且发布前端代码至chromium-history-page的gh-pages分支上 至此打开网页即可看到谷歌浏览器的历史版本。🚀🚀🚀 参考链接 仓库代码参考：chromium-history-version-crawler","link":"/blogs/articles/2021/04/06/download-chromium-history-version/"},{"title":"export 与 export default 的区别","text":"本文将介绍 export 与 export default 的差异性。 1. export default 在一个模块里只能有一个，但是 export 可以有多个123456789// model.jslet e1 = 'export 1';let e2 = 'export 2';let e3 = 'export 3';let e4 = 'export 4';export { e2 };export { e3 };export { e4 };export default e1; 1234567// 使用模块的run.jsimport e1, { e2, e3, e4 } from './model.js';console.log(e1);console.log(e2);console.log(e3);console.log(e4); 1234567run.js运行结果$ node run.jsexport 1export 2export 3export 4 如果在model.js再添加一个export default 12let e5 = 'export e5';export default e5; 123456$ node run.jsfile:///Users/xxx/workspace/model.js:11export default e5 ^^^^^^^^^^^SyntaxError: Identifier '.default' has already been declared 2. 模块中通过export 导出的(属性或者方法)可以修改，但是通过export default导出的不可以修改基本类型： 123456789// model.jslet e1 = 'export 1';let e2 = 'export 2';export function modifyFunc() { e1 = 'export 1 modified'; e2 = 'export 2 modified';}export { e2 };export default e1; 1234567// 使用模块的run.jsimport e1, { e2, modifyFunc } from './model.js';console.log(e1);console.log(e2);modifyFunc();console.log(e1);console.log(e2); 12345$ node run.jsexport 1export 2export 1export 2 modified Babel 编译后代码 123456789101112131415161718'use strict';Object.defineProperty(exports, '__esModule', { value: true,});exports.modifyFunc = modifyFunc;exports.default = exports.e2 = void 0;let e1 = 'export 1';let e2 = 'export 2';exports.e2 = e2;function modifyFunc() { e1 = 'export 1 modified'; exports.e2 = e2 = 'export 2 modified';}var _default = e1;exports.default = _default; 对象 123456789let e1 = { v1: 'v1' };let e2 = { v2: 'v2' };export function modifyFunc() { e1 = { v1: 'v1 modified' }; e1.v1 = 'v1 next modified'; e2 = { v22: 'v2 modified' };}export { e2 };export default e1; 1234567// 使用模块的run.jsimport e1, { e2, modifyFunc } from './model.js';console.log(e1);console.log(e2);modifyFunc();console.log(e1);console.log(e2); 12345$ node run.js{ v1: 'v1' }{ v2: 'v2' }{ v1: 'v1' }{ v22: 'v2 modified' } Babel 编译后代码 12345678910111213141516171819202122232425262728'use strict';Object.defineProperty(exports, '__esModule', { value: true,});exports.modifyFunc = modifyFunc;exports.default = exports.e2 = void 0;// model.jslet e1 = { v1: 'v1',};let e2 = { v2: 'v2',};exports.e2 = e2;function modifyFunc() { e1 = { v1: 'v1 modified', }; e1.v1 = 'v1 next modified'; exports.e2 = e2 = { v22: 'v2 modified', };}var _default = e1;exports.default = _default; 首先需要了解到： ES6 中模块通过export和export default暴露出来的属性或者方式并不是普通的赋值或者引用，它们是对模块内部定义的标志符类似指针的绑定。 对于一个导出的属性或者方法，在什么地方导出不重要，在什么时候导入也不重要，重要的是:访问这这个绑定的时候的当前值。 123456789// model.jslet e1 = 'export 1';let e2 = 'export 2';export { e2 };export default e1;e1 = 'export 1 modified';setTimeout(() =&gt; { e2 = 'export 2 modified';}, 1000); 1234567// 使用模块的run.jsimport e1, { e2 } from './model.js';console.log(e1);console.log(e2);setTimeout(() =&gt; { console.log('-----later-----', e2);}, 5000); 1234$ node run.jsexport 1export 2-----later----- export 2 modified Babel 编译后代码 12345678910111213141516'use strict';Object.defineProperty(exports, '__esModule', { value: true,});exports.default = exports.e2 = void 0;// model.jslet e1 = 'export 1';let e2 = 'export 2';exports.e2 = e2;var _default = e1;exports.default = _default;e1 = 'export 1 modified';setTimeout(() =&gt; { exports.e2 = e2 = 'export 2 modified';}, 1000); 但是，export是绑定到标识符，改变标志符的值，然后访问这个绑定，得到的是新值；export default绑定的是标志符指向的值，如果修改标志符指向另一个值，这个绑定的值不会发生变化。 如果想修改默认导出的值，可以使用export {e1 as default}这种方法。 1234// model.jslet e1 = 'export 1';export { e1 as default };e1 = 'export 1 modified'; 123// 使用模块的run.jsimport e1 from './model.js';console.log(e1); 123$ node run.jsexport 1 modified Babel 编译后代码 12345678910'use strict';Object.defineProperty(exports, '__esModule', { value: true,});exports.default = void 0;// model.jslet e1 = 'export 1';exports.default = e1;exports.default = e1 = 'export 1 modified'; 3. export default与export语法差异。 export var e1='...' 是合法语句，但是export default var e2='...'是不合法的（let和const也一样）。 export default可以直接添加标识符导出，例如export default e2;export如果要导出已经声明的表示符,必须使用{},例如export {e1},注意：这里{}不是声明一个对象。 可查看例子源码","link":"/blogs/articles/2021/06/03/export-export-default/"},{"title":"Git提交信息规范","text":"Git 每次提交代码，都要写 Commit message（提交说明） 1$ git commit -m &quot;hello world&quot; 上面代码的-m 参数，就是用来指定 commit mesage 的。 如果一行不够，可以只执行git commit，就会跳出文本编辑器，让你写多行. 1$ git commit Commit message 的格式每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。 12345&lt;Header&gt;&lt;Body&gt;&lt;Footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。 HeaderHeader 部分只有一行，包括三个字段：type（必需）、scope（可选）、subject（必需）。 1&lt;type&gt;: &lt;subject&gt; typetype 用于说明 commit 的类别，只允许使用下面 7 个标识。 feat：新功能（feature） fix：修补 bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 subjectsubject 是 commit 目的的简短描述，不超过 50 个字符。 以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes 第一个字母小写 结尾不加句号（.） BodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 1234567More detailed explanatory text, if necessary. Wrap it toabout 72 characters or so.Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent 有两个注意点。 使用第一人称现在时，比如使用 change 而不是 changed 或 changes。 应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用于两种情况： 关联 Issue 关闭 Issue 关联 Issue本次提交如果和摸个 issue 有关系则需要写上这个，格式如下： 1Issue #1, #2, #3 关闭 Issue如果当前提交信息解决了某个 issue，那么可以在 Footer 部分关闭这个 issue，关闭的格式如下： 1Close #1, #2, #3 Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 1234revert: feat(pencil): add 'graphiteWidth' optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body 部分的格式是固定的，必须写成 This reverts commit &amp;lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 例子12345678910feat: 添加了分享功能给每篇博文添加了分享功能- 添加分享到微博功能- 添加分享到微信功能- 添加分享到朋友圈功能Issue #1, #2Close #1 使用软件进行 commit 规范化 JS: commit-demo 参考文档 Commit message 和 Change log 编写指南 我的提交信息规范","link":"/blogs/articles/2021/03/31/git-commit-message/"},{"title":"工程化配置 git commit 规范","text":"如果你团队的 git commit 信息紊乱，太过糟糕，觉得有必要统一规范 commit格式，又或者你是一个强迫症患者，有必要让 commit 信息整整齐齐的展示。那么，你可以往下瞅瞅。 本文使用的插件版本 pkg123456{ &quot;@commitlint/cli&quot;: &quot;^12.0.1&quot;, &quot;@commitlint/config-conventional&quot;: &quot;^12.0.1&quot;, &quot;husky&quot;: &quot;4.3.8&quot;, &quot;standard-version&quot;: &quot;^9.1.1&quot;} git commit 规范格式现在比较大众化的 commit 格式无非有两种： git12$ &lt;commit-type&gt;[(commit-scope)]: &lt;commit-message&gt;$ &lt;commit-icon&gt;: &lt;commit-message&gt; &lt;commit-type&gt; 常见为： chore：构建配置相关。 docs：文档相关。 feat：添加新功能。 fix：修复 bug。 pref：性能相关。 refactor：代码重构，一般如果不是其他类型的 commit，都可以归为重构。 revert：分支回溯。 style：样式相关。 test：测试相关。 [(commit-scope)] 可选，表示范围，例如：refactor(cli)，表示关于 cli 部分的代码重构。 &lt;commit-message&gt; 提交记录的信息，有些规范可能会要求首字母大写。 &lt;commit-icon&gt; 用图标来替代 &lt;commit-type&gt; 所表示的功能。 具体规范信息格式在这里查看（这里不做过多阐述） 用于 commit 规范的工具 commitizen commitlint gitmoji 本文主要讲述第二种(commitlint)使用方法，如想使用更多请查看demo commitlint 使用yarn1$ yarn add @commitlint/config-conventional @commitlint/cli --D 在专门的 commitlint 配置文件 commitlint.config.js 中配置如下： commitlint.config.js123module.exports = { extends: ['@commitlint/config-conventional'],}; 类似于 eslint，commitlint 还支持类似于 .commitlintrc.js、.commitlintrc.json、.commitlintrc.yml 名称的配置文件，又或者在 package.json 中添加 commitlint 字段。 然后安装 husky，这是为了添加 git hooks，使得 git commit 也能够符合 commit 规范。 yarn1$ yarn add husky --dev 在 package.json 中配置 husky 钩子： (v1.0.1版本以后为HUSKY_GIT_PARAMS，v0.14.3为GIT_PARAMS) package.json1234567{ &quot;husky&quot;: { &quot;hooks&quot;: { &quot;commit-msg&quot;: &quot;commitlint -e $HUSKY_GIT_PARAMS&quot; } }} 上面的操作如果都成功的话，那么你使用 git commit 命令时，就必须老老实实的使用符合 commitlint 规范的信息了 standard-version 使用yarn1$ yarn add standard-version -D standard-version是帮助项目自动生成ChangeLog、升版本、打tag的工具，它基于semver和Conventional Commits规范。（PS：配合git commit规范化食用更加。 当执行server-version命令后，它会自动完成以下操作： 取得当前版本（比如package.json里面的version字段），升版本：1.0.0 =&gt; 1.1.0 或者 1.0.0 =&gt; 2.0.0等（如何升级可以由参数控制） 基于commits生成ChangeLog文件 提交一个commit，包含ChangeLog和版本变更的文件 打tag 以上功能都是可配置跳过的，对应：bump、changelog、commit、tag。比如在配置文件中按照如下配置，就可以跳过打tag操作： 12345{ &quot;skip&quot;: { &quot;tag&quot;: true }} 为standard-version添加配置有两种方式： 目前使用的配置文件如下，其它配置参考官方文档： .versionrc.js1234567891011121314151617181920212223242526272829303132333435363738394041424344// https://github.com/conventional-changelog/conventional-changelog-config-spec/blob/master/versions/2.1.0/README.mdmodule.exports = { // 跳过一些操作 bump、changelog、commit、tag skip: { // 不跳过打tag操作 tag: false, }, //types为Conventional Commits标准中定义，目前支持 //https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional types: [ { type: 'feat', section: '新特性' }, { type: 'fix', section: 'Bug修复' }, { type: 'docs', section: '文档' }, { type: 'chore', section: '配置项', hidden: true }, { type: 'style', section: '格式', hidden: true }, { type: 'refactor', section: '重构', hidden: true }, { type: 'perf', section: '性能', hidden: true }, { type: 'test', section: '测试', hidden: true }, { type: 'build', section: '构建', hidden: true }, { type: 'ci', section: 'CI', hidden: true }, { type: 'revert', section: '回滚', hidden: true }, ], //compare 链接 推荐自行修改为仓库地址 如 compareUrlFormat: '{{host}}/{{owner}}/{{repository}}/compare/{{previousTag}}...{{currentTag}}', //hash链接 推荐自行修改为仓库地址 如 https://github.com/MrSeaWave/commit-standard-demo/commit/{{hash}} commitUrlFormat: '{{host}}/{{owner}}/{{repository}}/commit/{{hash}}', //issue链接 issueUrlFormat: '{{host}}/{{owner}}/{{repository}}/issues/{{id}}', //server-version自动commit的模板 releaseCommitMessageFormat: 'build: v{{currentTag}}版本发布', //需要server-version更新版本号的文件 bumpFiles: [ { filename: 'MY_VERSION_TRACKER.txt', // The `plain-text` updater assumes the file contents represents the version. type: 'plain-text', }, { filename: 'package.json', // The `json` updater assumes the version is available under a `version` key in the provided JSON document. type: 'json', }, ],}; package.json 配置: package.json12345678&quot;scripts&quot;: { ..., &quot;release&quot;: &quot;standard-version&quot;, &quot;release:major&quot;: &quot;standard-version --release-as major&quot;, &quot;release:minor&quot;: &quot;standard-version --release-as minor&quot;, &quot;release:patch&quot;: &quot;standard-version --release-as patch&quot;, &quot;release:prerelease&quot;: &quot;standard-version --prerelease&quot; } PS: standard-version 有很多其他的特性，这里不过多涉及， 有兴趣的可以自行尝试。也可以查看此demo 参考链接 Git 的学与记：工程化配置 commit 规范 代码风格自动化","link":"/blogs/articles/2021/03/31/git-commit-cli/"},{"title":"git仓库的代理","text":"因为种种原因，github访问很困难，仓库代码的提交比较受限，因此想到通过挂代理的方式让代码可以正常提交。 首先第一步，肯定需要shdowsocks代理工具。 其次 全局设定： http1$ git config --global http.proxy http://127.0.0.1:1087 https1$ $ git config --global https.proxy https://127.0.0.1:1087 or 只针对特定仓库设定： http1$ git config http.proxy http://127.0.0.1:1087 https1$ git config https.proxy https://127.0.0.1:1087 注：127.0.0.1:1087是因为","link":"/blogs/articles/2021/04/02/git-proxy/"},{"title":"git-repository","text":"本文讲述如何上传本地代码到远程的空仓库。 Create a new repository123456git clone https://github.com/MrSeaWave/tem.gitcd temtouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin master Push an existing folder123456cd existing_foldergit initgit remote add origin https://github.com/MrSeaWave/tem.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master Push an existing Git repository12345cd existing_repogit remote rename origin old-origingit remote add origin https://github.com/MrSeaWave/tem.gitgit push -u origin --allgit push -u origin --tags","link":"/blogs/articles/2021/06/03/git-repository/"},{"title":"hexo 相关问题以及优化配置","text":"前言本文记录一些 hexo 出现的问题及其解决方案，以及相关配置 hexo 环境 env1234hexo: 5.3.0hexo-cli: 4.2.0os: Darwin 19.6.0 darwin x64node: 15.2.1 禁止爬虫跟踪外链搜索引擎的蜘蛛来爬取文章内容时，如果你的文章中有外部链接，它就会到外链的站点去爬取，有可能再也不会回来了。为了告诉搜索引擎不要跟踪这些外链，需要在这些链接标签中添加属性 rel=&quot;nofollow&quot; 或 rel=&quot;external nofollow&quot; 。 rel=&quot;nofollow&quot; 是通用格式，即是告诉搜索引擎不要跟踪此链接，rel=&quot;external nofollow&quot; 是更具体的写法，进一步告诉搜索引擎这是一个外部的链接，不要跟踪它。 我们可以使用 hexo-filter-nofollow 自动为 Hexo 博客中的外链添加 rel=&quot;external nofollow noreferrer&quot;的插件，从而改善你的网站的安全性和 SEO。 安装install1$ npm i hexo-filter-nofollow --save 编辑 _config.yml在 站点配置文件 _config.yml 末尾添加如下内容： _config.yml123456nofollow: enable: true field: site exclude: - 'exclude1.com' - 'exclude2.com' enable - 是否启用插件，默认值为 true field - 插件的处理范围，默认值为 site，可选 post 或 site post - 仅处理文章内容 site - 处理全站所有页面 exclude - 域名白名单，不同的子域名视为不同的域名（如 www） exclude1.com不包括 www.exclude1.com 或 en.exclude1.com 永久链接因链接层级过深、链接中包含中文、 title 变动导致链接也经常发生变动，这些都不利于 SEO 。 方法一：按照文件名称生成假设文章： md123456# source/_posts/lorem/hello-world.mdtitle: Hello World Pagedate: 2013-07-14 17:01:34categories: - foo - bar 根据官网介绍在_config.yml中设定： _config.yml123456# title: 文件名称 (relative to “source/_posts/“ folder)permalink: :title/# url:-----&gt; /lorem/hello-world/# name: 文件名称permalink: :name/# url:-----&gt; /hello-world/ 问题来了，如果按照文件名称生成永久链接的，我的文件格式都要是这类 英文字母.md 的格式。如果是中文中文.md那么就会变成/中文/，浏览器地址栏上很不美观，对 SEO 也不好。 有没有办法让 Markdown 文件用 你好世界.md 这类中文文件名保存，生成的永久链接格式又是 /hello-world/ 这种样式呢？ Markdown Front-matter 区域可以看到，我这里除了 title， date 以及 tags 外，自己添加了一个新的变量 customUrl ，这个新的变量用来保存每个文章的英文名字，这样一来可以有利于 SEO，二来可以缩短博客文章 URL 的层数。 front-matter123title: Hello World Page# 自定义的变量customUrl: custom-hello-world 再在 hexo 配置文件 _config.yml 中，把 permalink: 的值设为 :customUrl/ 。 _config.yml12permalink: :customUrl/# url:------&gt; /custom-hello-world/ 方法二：使用 hexo-abbrlink推荐使用插件 hexo-abbrlink 生成 permalink 。 安装install1$ npm install hexo-abbrlink --save 使用然后在配置文件_config.yml 中修改： _config.yml12345permalink: :abbrlink/#abbrlink配置abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 执行 hexo clean &amp;&amp; hexo g 重新生成静态文件后，源文件 front-matter 中会包含 abbrlink: xxx 。 如果文章中未指定 abbrlink: xxx，将会根据算法随机生成数字 这样就确保了链接的唯一化，只要不修改 md 文件的 abbrlink 的值，url 就永久不会改变。 使用这种方法生成 permalink 时，在每次提交修改前，最好先执行 hexo clean &amp;&amp; hexo g，确保提交前你所有的文章的 front-matter 中都包含 abbrlink ，避免因 title 的改变导致生成 abbrlink 不一致（如果已存在 abbrlink，就不会重新生成，不论title 是否发生变化）。 参考链接 Hexo 相关问题和优化 hexo-filter-nofollow - Hexo 官方的 nofollow 插件 Hexo 永久链接管理 永久链接（Permalinks） hexo-abbrlink","link":"/blogs/articles/2021/01/08/hexo-configuration/"},{"title":"如何在Hexo中对文章md文件分类","text":"本文将介绍如何在 Hexo 中对文章 md 文件按日期进行分类 起因在默认配置下，我们使用hexo new post [title]会在source/_post/目录下生成对应的markdown文件，当我们写的博客越来越多的时候，会发现，所有文章都是在source/_post/下，查找起来会不大方便，因此希望对它进行一个分类，但是在生成的文章链接上保持不变。 方法通过查看hexo 配置文档 发现： permalink 用于设置文章的永久链接格式new_post_name 新文章的文件名称 因此我们可以通过配置new_post_name让创建的文件按时间分类，其次可通过new命令指定创建时的文件路径(hexo new page --path about/me &quot;About me&quot;)，从而进行归类。 这里介绍new_post_name方法，我们可以指定： 12permalink: 'articles/:year/:month/:day/:name/'new_post_name: ':year/:title.md' 这时候每次运行hexo new post [title]时新建的文件将按年份存放，生成的 html 文件将会按照年月日展示，比如source/_post/2021/test.md对应的博客地址：2021/06/25/test/。 整理现在新建文章的路径我们是已经处理好了，那以前创建的文章是不是要一个个手动分类呢？这里参考此文章，我们可以使用终端进行处理： 思路为： 找出 2021 年的文章 移动到 2021 文件夹下 找出 2020 年的文章，按 1-2 步的方式处理…… 1234567891011# 进入_post目录cd source/_post# 创建一个2021年1月1日的文件，用于过滤出2018年的文章touch -t 202101010000 timestamp# 创建2021文件夹mkdir 2021# 将2021年的文章移到2021文件夹下for file in `find . -type f -newer timestamp`; do mv $file 2021 ; done# 删除刚才创建的用于过滤的文件rm timestamp 参考链接 如何在 Hexo 中对文章 md 文件分类","link":"/blogs/articles/2021/06/25/hexo-new-post-path/"},{"title":"Husky hooks skipped","text":"在sourceTree遇到使用husky 会报错的情况： error123....Can't find yarn in PATH:......Skipping pre-push hook 解决方案： add this in ~/.huskyrc: huskyrc1PATH=&quot;/usr/local/bin:$PATH&quot; 参考链接 Husky hooks skipped Commit hooks are skipped due to PATH issues","link":"/blogs/articles/2021/04/02/husky-error-gui/"},{"title":"Prettier: support &quot;overrides&quot; option on code styles import","text":"在直接调用 WebStorm 自带的 Prettier 去格式化 wxml / wxss / wxs 文件会提示： File xxx has unsupported type 猜想 Prettier 应该提供任意文件映射为任意已支持的文件类型的格式化配置。查阅官方文档后：Setting the parser option，于是有了下面配置。 prettierrc123456789101112131415161718192021222324{ &quot;prettier&quot;: { &quot;overrides&quot;: [ { &quot;files&quot;: &quot;*.wxml&quot;, &quot;options&quot;: { &quot;parser&quot;: &quot;html&quot; } }, { &quot;files&quot;: &quot;*.wxss&quot;, &quot;options&quot;: { &quot;parser&quot;: &quot;css&quot; } }, { &quot;files&quot;: &quot;*.wxs&quot;, &quot;options&quot;: { &quot;parser&quot;: &quot;babel&quot; } } ] }} 于是在某个小程序文件中再次尝试调用 WebStorm 自带的 Prettier，发现依然是那个错误提示，重启也无果。。但是 vscode 却可以正常使用了。 又试了下手动在命令行里敲： 1npx prettier xx --write 成功，于是判断问题出在 webstorm 上。 尝试修复： 全局安装 Prettier，这样方便跨项目复用（可选 Preferences - Tools - External Tools 点击当前窗口左下角 + 号 Name、Description 自己起一个吧 Program 里填写：Prettier 安装位置/bin-prettier.js Arguments 里填写：$FilePath$ --write Working directory 不用管，ok、apply 双连保存配置 以上步骤完成之后你就可以通过顶部菜单：Tools - External Tools - 你起的 Tool Name 来格式化当前的小程序文件了。再说说快捷键的配置步骤： Preferences - Keymap 当前窗口右上角搜索你创建的 Tool Name 在搜索结果里选中它 Add Keyboard Shortcut 吧！ 参考链接 WebStorm 微信小程序代码提示 + Prettier 代码格式化 Prettier: support “overrides” option on code styles import","link":"/blogs/articles/2021/04/14/idea-prettier/"},{"title":"rust 安装","text":"Rust 通常被称为 rust-lang。Rust 是一个由 Mozilla Research 赞助的通用的、多范式、现代的、跨平台和开源系统编程语言。 它旨在实现安全性、速度和并发性等目标。 Rust 在语法上与 C++ 相似，但它的设计者希望它在保持性能的同时提供更好的内存安全性。 Rust 目前在许多组织中使用，例如 Firefox、Chef、Dropbox、Oracle、GNOME 等。 如何在 Mac 中安装 Rust 语言？我们可以通过多种方式安装 Rust，但以下是官方推荐的安装方式。 install12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | shinfo: downloading installerWelcome to Rust!This will download and install the official compiler for the Rustprogramming language, and its package manager, Cargo.Rustup metadata and toolchains will be installed into the Rustuphome directory, located at: /Users/xmly/.rustupThis can be modified with the RUSTUP_HOME environment variable.The Cargo home directory located at: /Users/xmly/.cargoThis can be modified with the CARGO_HOME environment variable.The cargo, rustc, rustup and other commands will be added toCargo's bin directory, located at: /Users/xmly/.cargo/binThis path will then be added to your PATH environment variable bymodifying the profile files located at: /Users/xmly/.profile /Users/xmly/.zshenvYou can uninstall at any time with rustup self uninstall andthese changes will be reverted.Current installation options: default host triple: x86_64-apple-darwin default toolchain: stable (default) profile: default modify PATH variable: yes1) Proceed with installation (default)2) Customize installation3) Cancel installation&gt;info: profile set to 'default'info: default host triple is x86_64-apple-darwininfo: syncing channel updates for 'stable-x86_64-apple-darwin'info: latest update on 2020-12-31, rust version 1.49.0 (e1884a8e3 2020-12-29)info: downloading component 'cargo' 4.1 MiB / 4.1 MiB (100 %) 3.3 MiB/s in 1s ETA: 0sinfo: downloading component 'clippy'info: downloading component 'rust-docs' 13.8 MiB / 13.8 MiB (100 %) 2.3 MiB/s in 6s ETA: 0sinfo: downloading component 'rust-std' 21.1 MiB / 21.1 MiB (100 %) 2.3 MiB/s in 9s ETA: 0sinfo: downloading component 'rustc' 50.8 MiB / 50.8 MiB (100 %) 2.3 MiB/s in 22s ETA: 0sinfo: downloading component 'rustfmt'info: installing component 'cargo'info: using up to 500.0 MiB of RAM to unpack componentsinfo: installing component 'clippy'info: installing component 'rust-docs' 13.8 MiB / 13.8 MiB (100 %) 3.4 MiB/s in 4s ETA: 0sinfo: installing component 'rust-std' 21.1 MiB / 21.1 MiB (100 %) 3.6 MiB/s in 5s ETA: 0sinfo: installing component 'rustc' 50.8 MiB / 50.8 MiB (100 %) 7.4 MiB/s in 7s ETA: 0sinfo: installing component 'rustfmt'info: default toolchain set to 'stable-x86_64-apple-darwin' stable-x86_64-apple-darwin installed - rustc 1.49.0 (e1884a8e3 2020-12-29)Rust is installed now. Great!To get started you need Cargo's bin directory ($HOME/.cargo/bin) in your PATHenvironment variable. Next time you log in this will be doneautomatically.To configure your current shell, run:source $HOME/.cargo/env 运行以下命令配置当前 shell。 source1$ source $HOME/.cargo/env 运行以下命令验证已安装的 Rust 版本。 rust version12$ rustc --versionrustc 1.49.0 (e1884a8e3 2020-12-29) 如何测试 Rust 编程语言安装 Rust 后，请按照以下步骤检查 Rust 语言是否正常工作。 创建一个文件并添加以下代码并保存。确保 Rust 文件始终以 .rs 扩展名结尾。 index1234$ vim index.rsfn main() { println!(&quot;Hello World&quot;);} 运行以下命令编译 rust 代码。 rust1$ rustc index.rs 上面的命令将在同一目录中创建一个可执行的 Rust 程序。 ls1234$ ls -lhtotal 760-rwxr-xr-x 1 xmly staff 375K 1 20 10:45 index-rw-r--r-- 1 xmly staff 41B 1 20 10:36 index.rs 运行 Rust 可执行文件得到输出。 run12$ ./indexHello World 好了！正常工作了。 参考链接 Rustup for managing Rust versions rust","link":"/blogs/articles/2021/01/20/install-rust/"},{"title":"如何杀死lcasensor进程","text":"本文讲述如何杀死 lcasensor（内网的监控软件，敏感数据监控）这个进程。 一下操作均是在 MacOs 环境下运行。 1. 定位进程信息1$ ps aux |grep didi 找到 4 个相似进程： /opt/didi/lca/bin/lcasensor /opt/didi/lca/bin/lcaupdater /opt/didi/lca/bin/LCAService /opt/didi/lca/bin/lcaagent 2. 检查自动启动目录 /Library/LaunchDaemons /Library/LaunchAgents ~/Library/LaunchAgents /System/Library/LaunchDaemons /System/Library/LaunchAgents 找到 4 份配置文件： /Library/LaunchAgents/com.didi.lca.lcaagent.plist /Library/LaunchDaemons/com.didi.lca.lcasensor.plist /Library/LaunchDaemons/com.didi.lca.lcaservice.plist /Library/LaunchDaemons/com.didi.lca.lcaupdater.plist 3. 修改自动启动选项分别修改com.didi.lca.*.plist的内容，主要改下面 2 个地方。 请确认修改以后的效果是：KeepAlive=false，RunAtLoad=false com.didi.lca.*.plist1234&lt;key&gt;KeepAlive&lt;/key&gt;&lt;false/&gt;&lt;key&gt;RunAtLoad&lt;/key&gt;&lt;false/&gt; 4. 重新启动电脑验证检查一下进程信息，确认进程已经停止运行 1$ ps aux |grep didi 删除上述提到的相关文件即可避免再次运行 1234$ sudo rm -rf /Library/LaunchAgents/com.didi.lca.*.plist$ sudo rm -rf /Library/LaunchDaemons/com.didi.lca.*.plist$ sudo rm -rf /opt/didi/lca$ sudo rmdir /opt/didi End! 🎉🎉🎉 参考链接 知乎","link":"/blogs/articles/2021/04/16/kill-lcasensor/"},{"title":"koa后端数据校验","text":"对每个接口的传入参数进行校验，是一个 Web 后端项目的必备功能，本文将介绍 koa 中如何使用joi进行数据格式检验。 安装 Joi1$ yarn add Joi 接下来将以对register的user进行后端数据校验为例 创建数据校验中间件middlewares/validator.js 12345678910111213141516171819/** * @desc 数据校验中间件 * @param {function} validateFunc validators 里的校验器函数 */function validatorMiddleware(validateFunc) { return async function validator(ctx, next) { const { error } = validateFunc(ctx.request.body); if (error) { console.log('校验器【 %s 】，数据校验失败', validateFunc.name); console.error(error); // 使用joi时的自定义错误||joi提供的错误展示 ctx.body = error.message || error.details[0].message; return; } await next(); };}export default validatorMiddleware; 创建 User 校验规则，并校验src/validators/user.js 123456789101112131415161718/** * 校验用户数据格式 * @param {Object} data 用户数据 */export function userValidator(data) { const schema = Joi.object({ userName: Joi.string() .min(2) .max(255) .pattern(/^[a-zA-Z][a-zA-Z0-9_]+$/) .required(), password: Joi.string() .pattern(/^[a-zA-Z0-9]{3,30}$/) .error(new Error('密码格式不对，请重新设定')), repeat_password: Joi.ref('password'), }); return schema.validate(data);} 注册接口使用数据校验中间件，传入 userValidator 校验 Usersrc/routes/user.js 12345678910import Router from '@koa/router';import validatorMiddleware from '../middlewares/validator';import { handleUserRegister } from '../controllers/user';import { userValidator } from '../validators/user';const router = new Router({ prefix: '/user' });router.post('/register', validatorMiddleware(userValidator), handleUserRegister);export default router; 更多校验方法 ajv：基于JSON Schema的数据校验库 JSON Schema： JSON Schema 并不是某个库，只是一种标准，简单的来说就是通过 json 格式来描述数据，而 ajv 就是对 JSON Schema 的具体实现之一. class-validator：采用注解的方式进行校验，底层使用的是老牌的校验包validator.js，配合ts语法进行使用。 routing-controllers ：使用ts构建的一个帮助很方便处理router的框架 参考链接 Koa+TypeScript 从 0 到 1 实现简易 CMS 框架（三）：用户模型、参数校验与用户注册接口 使用 class-validator 替换 Joi 包的方法 koa 后端数据校验-ajv 项目重构记录","link":"/blogs/articles/2021/07/06/koa-validator/"},{"title":"lerna","text":"lerna-demoLerna 是一个工具，它优化了使用 git 和 npm 管理多包存储库的工作流。 本文通过一个示例讲述了如何基于 Lerna 管理多个 package，并和其它工具整合，打造高效、完美的工作流，最终形成一个最佳实践。 工作的两种模式Fixed/Locked mode (default)vue,babel 都是用这种，在 publish 的时候,会在 lerna.json 文件里面&quot;version&quot;: &quot;0.1.0&quot;依据这个号，进行增加，只选择一次，其他有改动的包自动更新版本号。 Independent modelerna init --independent 初始化项目。 lerna.json 文件里面&quot;version&quot;: &quot;independent&quot;, 每次 publish 时，您都将得到一个提示符，提示每个已更改的包，以指定是补丁、次要更改、主要更改还是自定义更改。 项目构建init12$ mkdir lerna-demo &amp;&amp; cd $_$ npx lerna init 生成以下文件 1234lerna-demo/ packages/ package.json lerna.json 增加 packages创新一些新的 pkg 123456789101112$ cd packages$ mkdir pkg-a pkg-b pkg-c$ cd pkg-a$ npm init --y$ cd pkg-b$ npm init --y或者使用$ lerna create pkg-d --y 项目结构如下 123456789101112131415161718192021$ tree.├── README.md├── lerna.json├── package.json└── packages ├── pkg-a │ └── package.json ├── pkg-b │ └── package.json ├── pkg-c │ └── package.json └── pkg-d ├── README.md ├── __tests__ │ └── pkg-d.test.js ├── lib │ └── pkg-d.js └── package.json7 directories, 10 files 依赖管理 yarn是lerna的最佳搭档。 lerna默认使用npm作为安装依赖包工具，但也可以选择其他工具。把 npm 替换成 yarn 只需在 lerna 的配置文件添加两行代码即可，配置完以后立刻顺畅百倍。 1234567// lerna.json{ &quot;packages&quot;: [&quot;packages/*&quot;], // 配置package目录 &quot;version&quot;: &quot;independent&quot;, &quot;npmClient&quot;: &quot;yarn&quot;, &quot;useWorkspaces&quot;: true // 使用yarn workspaces} 配置 package.json 使用yarn workspaces 1234567891011{ &quot;name&quot;: &quot;root&quot;, &quot;private&quot;: true, // root禁止发布 &quot;devDependencies&quot;: { &quot;lerna&quot;: &quot;^4.0.0&quot; }, &quot;workspaces&quot;: [ // 配置package目录 &quot;packages/*&quot; ]} 安装依赖只要在项目主目录下执行 1$ yarn install yarn 会自动读取 workspace 配置，就能自动安装、处理、软链接各个子包的依赖，统一放在根目录下。也可以使用 lerna 的安装命令 1$ lerna bootstrap 但可能不如 yarn 的包管理机制好用，可以看这篇文章《Lerna 的依赖管理及 hoisting 浅析》 增删依赖123$ lerna add chalk # 为所有 package 增加 chalk 模块$ lerna add semver --scope pkg-a # 为 pkg-a 增加 semver 模块$ lerna add pkg-a --scope pkg-b # 增加内部模块之间的依赖 or 123$ yarn workspaces run add chalk # 为所有 package 增加 chalk 模块$ yarn workspace pkg-a add semver # 为 pkg-a 增加 semver 模块$ yarn workspace pkg-b add pkg-a@1.0.0 # 这里必须加上版本号，否则报错,将pkg-a作为pkg-b的依赖 更多请查看lerna add 对应的 yarn 的更多命令： 主项目添加依赖 1$ yarn add [packageName] -W -D -W 是指定在项目根目录执行命令 删除公共依赖 1$ yarn remove -W -D [packageName] 给所有子项目增删依赖 12$ yarn workspaces run add [packageName]$ yarn workspaces run remove [packageName] 给某个项目增删依赖 1$ yarn workspace [packageNameA] add [packageNameB] // packageNameA是指定安装依赖的包名，packageNameB是公共的包名或者项目内的包名 1$ yarn workspace [packageName] remove [packageName] 当项目依赖凌乱的时候，可以使用命令清理依赖 1$ lerna clean 其余还有一些命令如下，更多命令参考lerna 123lerna ls // 列出仓库中包信息lerna changed // 查看项目变动lerna exec // 执行命令 12lerna run &lt; script &gt; -- [..args] # 运行所有包里面的有这个script的命令$ lerna run --scope my-component test 1yarn workspaces info // 查看项目内信息 构建使用lerna run命令构建项目 1$ lerna run build // 会执行子包中build命令构建 发布123$ lerna publish # 发布自上一个版本以来发生了变化的包$ lerna publish from-git # 发布当前提交中标记的包$ lerna publish from-package # 发布注册表中没有最新版本的包 在运行时，该命令做了下面几件事中的一个： 发布自上一个版本以来更新的包(背后调用了 lerna version)。 这是 lerna 2.x 版本遗留下来的。 发布在当前提交中标记的包(from-git)。 发布在最新提交时注册表中没有版本的包(from-package)。 发布在前一次提交中更新的包(及其依赖项)的“金丝雀(canary)”版。 注意Lerna 永远不会发布标记为 private 的包（package.json 中的”private“: true） 在所有的发布过程中，都有生命周期在根目录和每个包中运行(除非使用了--ignore-scripts)。 请查看每个包的配置以了解发布作用域限定的包、自定义注册表和自定义标记的详细信息。 不支持只发布某个 packagelerna 官方不支持仅发布某个 package，见 issues/1691，如果需要，只能自己手动的进入 package 进行发布，这样 lerna 自带的各种功能就需要手动完成且可能和 lerna 的功能相互冲突 由于 lerna 会自动的监测 git 提交记录里是否包含指定 package 的文件修改记录，来确定版本更新，这要求设置好合理的 ignore 规则（否则会造成频繁的，无意义的某个版本更新），好处是其可以自动的帮助 package 之间更新版本 例如如果pkg-b 依赖了 pkg-a，如果 pkg-a 发生了版本变动，会自动的将 pkg-b 的对 pkg-a 版本依赖更新为 pkg-a 的最新版本。 如果 pkg-b 发生了版本变动，对 pkg-a 并不会造成影响。 版本迭代lerna 通过 version 命令来为各个模块进行版本迭代。基本命令如下： 1$ lerna version [major | minor | patch | premajor | preminor | prepatch | prerelease] 如果不选择此次迭代类型，则会进入交互式的提示流程来确定此次迭代类型 例如： 123$ lerna version 1.0.1 # 按照指定版本进行迭代$ lerna version patch # 根据 semver 迭代版本号最后一位$ lerna version # 进入交互流程选择迭代类型 自动生成 CHANGELOG当您使用这个参数运行时，lerna version将使用传统的提交规范来确定版本并生成 CHANGELOG.md 文件 1$ lerna version --conventional-commits 自动确立了版本更新 经测试 version_bump 是依赖于文件检测和 subject 结合，并不依赖于 scope，scope 的作用是用来生成 changelog 的吧，即如果是修改了 pkg-b 的文件，但是 commit 记录写的是 fix(pkg-a)，lerna 是会生成 pkg-b 的版本更新，并不会去更新 pkg-a 的版本 手动选择发布版本如果 git commit message 发现不太靠谱，且无法修改的话，那么需要手动的确认新版本，version 默认是手动选择版本 1$ lerna version version 成功后会自动的推送到主分支 lerna version 自动生成的提交格式为“ publish xxx”,并不符合 conventional-commit 规范，因此需要加以修改，我们通过 message 参数可以修改自动生成的提交记录 123456789101112// lerna.json{ &quot;packages&quot;: [&quot;packages/*&quot;], &quot;version&quot;: &quot;independent&quot;, &quot;npmClient&quot;: &quot;yarn&quot;, &quot;useWorkspaces&quot;: true, &quot;command&quot;: { &quot;publish&quot;: { &quot;message&quot;: &quot;chore: publish&quot; } }} 例子项目例子可参考eg 参考链接 lerna lerna 中文 基于 Lerna 管理 packages 的 Monorepo 项目最佳实践 基于 lerna 和 yarn workspace 的 monorepo 工作流 Lerna 中文教程详解 大前端项目代码重用，也许 lerna 是最好的选择 使用 Lerna、Yarn 管理 Monorepo 项目","link":"/blogs/articles/2021/06/07/lerna/"},{"title":"Mac 上的 APP 推荐","text":"值得推荐的 mac 软件 开发相关 IDEA：编辑器 vscode：编辑器 sourceTree：git GUI Charles：HTTP 信息抓包工具 Postman：测试 Web API &amp; HTTP iTerm2：强大的终端神器 Sequel Pro：My Sql 管理页面 Redis Desktop Manager：Redis 管理页面 Dash 程序员的 API 文档查询利器 基本软件 Alfred （神器 Bartender （Menubar 菜单栏管理小助手 系统清理 CleanMyMac X App Cleaner &amp; Uninstaller（应用深度清理卸载工具 Typora （markdown 书写工具 Upic（Mac 图床客户端 截图 xnip (截图) 带有滚动效果，推荐 LICEcap （录制 gif） gifox (录制 gif，无点击效果) Snipaste （截图） Text Scanner（将图片上文字内容转换成可编辑文本） Kap (屏幕录像&amp;&amp;录制 gif) 带有点击效果，推荐 时间管理 OmniFocus Recess （时间管理，强制休息） 绘图软件 OmniGraffle 团队管理，任务管理 teambition 笔记、知识库 notion 思维导图 xmind 幕布 TeamView（远程操作 1Password （保存密码 outlook（邮箱 The Unarchiver（解压缩工具 ShadowsocksX-NG-R8（Vpn 屏保 机械手表 WatchOSX 倒计时 CountDown 翻页式钟表 fliqlo Sip（屏幕取色工具 IINA（视频播放工具 Paste（剪贴板 ScreenFlow（屏幕录像&amp;&amp;视频剪辑 KeyCastr（显示按键操作 Xscope (强大的设计辅助软件，标尺) Reeder（RSS 订阅器新闻阅读器 Yoink（一款移动复制文件效率工具","link":"/blogs/articles/2021/03/23/mac-apps/"},{"title":"myBlogTestEmail","text":"","link":"/blogs/articles/2021/01/05/myBlogTestEmail/"},{"title":"node端生成水印图片","text":"在项目中通常会出现给图片增加水印的需求，本文将介绍如何在使用 node 时处理图片，增加水印功能。 文字和图片不能直接合并，需要将文字先转换成图形，然后再将图形进行合并，大致步骤如下： 利用text-to-svg，将文字转成 SVG 图形； 利用sharp，将 SVG 图形与背景图片合并； 生成水印图片将文字转换为 SVG 图形，需要借助 Node 的模块text-to-svg，该模块能够将文字按照指定字体生成 SVG 图形 代码如下： 123456789101112131415161718/** * @desc 将水印文字转换成 svg，再转换成buffer * @param {string} text 水印文字 * @param {number} fontSize 字体大小 * @param {string} color 字体颜色 * @return {Buffer} */function text2SVG({ text, fontSize = 72, color = 'rgba(204,204,204,0.45)' }) { // 加载字体文件 const text2SVG = Text2SVG.loadSync(path.resolve(__dirname, '../../assets/PingFang-SC-Regular.ttf')); const options = { fontSize, anchor: 'top', // 坐标中的对象锚点 attributes: { fill: color }, // 文字颜色 }; const textSVG = text2SVG.getSVG(text, options); return Buffer.from(textSVG);} 这时候生成的水印图片是平行文字： 我们需要旋转 45 度后的图片： 代码如下： 123456789101112/** * @desc 水印图片旋转45度倾斜 * @param {string} text 水印文字 * @return {Promise&lt;Buffer|*&gt;} */async function rotateWatermarkBuffer(text) { // ` ${text} ` 增加下文字间距 const textBuffer = text2SVG({ text: ` ${text} ` }); return sharp(textBuffer) .rotate(45, { background: { r: 255, g: 255, b: 255, alpha: 0 } }) // 旋转45度，并且透明色 .toBuffer();} 合并图形用于合并图片的库有很多，比如gm、jimp、mapnik、sharp等，其中sharp是基于libvips库来实现的，性能是最高的，所以采用了 sharp 来合并图形。 123456789101112131415/** * @desc 入口文件 * @param {string|Buffer} img 图片本地路径或图片 Buffer 数据 * @param {string} text 水印文字 * @param {string} filepath 保存合成水印后的文件路径 * @return {Promise&lt;Object&gt;} */async function init({ img, text, filepath }) { const textBuffer = await rotateWatermarkBuffer(text); const imgInfo = await sharp(img) // 重复（tile）合并图像 .composite([{ input: textBuffer, tile: true }]) .toFile(filepath); return imgInfo;} 最终代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const path = require('path');const sharp = require('sharp');const Text2SVG = require('text-to-svg');async function nodeGenWatermark({ img, text, filepath }) { /** * @desc 将水印文字转换成 svg，再转换成buffer * @param {string} text 水印文字 * @param {number} fontSize 字体大小 * @param {string} color 字体颜色 * @return {Buffer} */ function text2SVG({ text, fontSize = 72, color = 'rgba(204,204,204,0.45)' }) { const fontPath = path.resolve(__dirname, '../../assets/PingFang-SC-Regular.ttf'); // 加载字体文件 const text2SVG = Text2SVG.loadSync(fontPath); const options = { fontSize, anchor: 'top', // 坐标中的对象锚点 attributes: { fill: color }, // 文字颜色 }; const textSVG = text2SVG.getSVG(text, options); return Buffer.from(textSVG); } /** * @desc 水印图片旋转45度倾斜 * @param {string} text 水印文字 * @return {Promise&lt;Buffer|*&gt;} */ async function rotateWatermarkBuffer(text) { // ` ${text} ` 增加下文字间距 const textBuffer = text2SVG({ text: ` ${text} ` }); return sharp(textBuffer) .rotate(45, { background: { r: 255, g: 255, b: 255, alpha: 0 } }) // 旋转45度，并且透明色 .toBuffer(); } /** * @desc 入口文件 * @param {string|Buffer} img 图片本地路径或图片 Buffer 数据 * @param {string} text 水印文字 * @param {string} filepath 保存合成水印后的文件路径 * @return {Promise&lt;Object&gt;} */ async function init({ img, text, filepath }) { const textBuffer = await rotateWatermarkBuffer(text); const imgInfo = await sharp(img) // 重复（tile）合并图像 .composite([{ input: textBuffer, tile: true }]) .toFile(filepath); return imgInfo; } await init({ img, text, filepath });}nodeGenWatermark({ img: path.resolve(__dirname, '../../assets/chrome.png'), text: '水印', filepath: path.resolve(__dirname, '../../assets/output.png'),}); 至此，我们就实现了一个简单的给图片加水印的功能，让我们看看生成效果： 参考链接 sharp text-to-svg sharp 使用文档 node 文字生成图片 Node.js 服务端图片处理利器——sharp 进阶操作指南","link":"/blogs/articles/2021/07/13/node-watermark/"},{"title":"优化puppeteer","text":"本文将讲述如何优化puppeteer 什么是 puppeteer Puppeteer 是一个 Node 库，它提供了高级 API 来通过 DevTools 协议控制 Chromium 或 Chrome。 通过Puppeteer我们可以编写脚本模拟浏览器的相关行为，实现以下功能： 网页截图并保存为图片或 pdf 。 模拟表单提交，键盘输入，按钮点击，滑块移动等 dom 操作。 实现 UI 的自动化测试。 作为抓包工区对网页性能进行调试和分析。 编写定制化爬虫，解决传统 HTTP 抓取 SPA 页面难以处理异步请求的问题。 为什么要优化随着最近项目进度的复杂，项目在使用 Puppeteer 时遇到一些问题，这些问题包括：经常卡住，运行慢、卡，浏览器关不掉，CPU 和 内存 经常是满载运行的，特别是 CPU ，经常是 99% 的使用率。 Chromium 消耗最多的资源是 CPU，一是渲染需要大量计算，二是 Dom 的解析与渲染在不同的进程，进程间切换会给 CPU 造成压力（进程多了之后特别明显）。 其次消耗最多的是内存，Chromium 是以多进程的方式运行，一个页面会生成一个进程，一个进程占用 30M 左右的内存，大致估算 1000 个请求占用 30G 内存，在并发高的时候内存瓶颈最先显现。 优化最终会落在内存和 CPU 上（所有软件的优化最终都要落到这里），通常来说因为并发造成的瓶颈需要优化内存，计算速度慢的问题要优化 CPU。 优化点优化 Chromium 启动项 如果将 Dom 解析和渲染放到同一进程，肯定能提升时间（进程上下文切换的时间）。对应的配置是 single-process 部分功能 disable 掉，比如 GPU、Sandbox、插件等，减少内存的使用和相关计算。 代码如下： 123456789101112const browser = await puppeteer.launch({ headless: true, // 以 无头模式（隐藏浏览器界面）运行浏览器 args: [ '--disable-gpu', // GPU硬件加速 '--disable-dev-shm-usage', // 创建临时文件共享内存 '--disable-setuid-sandbox', // uid沙盒 '--no-first-run', // 没有设置首页。在启动的时候，就会打开一个空白页面。 '--no-sandbox', // 沙盒模式 '--no-zygote', '--single-process', // 单进程运行 ],}); 复用 browser每次请求都启动 Chromium，再打开 tab 页，请求结束后再关闭 tab 页与浏览器。 流程大致如下： 请求到达 -&gt; 启动 Chromium -&gt; 打开 tab 页 -&gt; 运行代码 -&gt; 关闭 tab 页 -&gt; 关闭 Chromium -&gt; 返回数据 真正运行代码的只是 tab 页面，理论上启动一个 Chromium 程序能运行成千上万的 tab 页，可不可以复用 Chromium 只打开一个 tab 页然后关闭呢？ 当然是可以的。 Puppeteer 提供了 puppeteer.connect() 方法，可以连接到当前打开的浏览器。而且puppeteer.connect比puppeteer.launch启动一个浏览器实例要快很多（参考) 流程如下： 请求到达 -&gt; 连接 Chromium -&gt; 打开 tab 页 -&gt; 运行代码 -&gt; 关闭 tab 页 -&gt; 返回数据 代码如下： 123456789101112131415// 使用缓存wsEndpointconst wsEndpoint = this.wsEndpoint;let browser;try { browser = !wsEndpoint ? await puppeteer.launch(config) : await puppeteer.connect({ browserWSEndpoint: this.wsEndpoint, });} catch (err) { browser = await puppeteer.launch(config);} finally { // 缓存wsEndpoint this.wsEndpoint = browser.wsEndpoint();} 在进一步优化是在程序启动时，初始化一定数量的无头浏览器，并保存 WSEndpoint 列表，当收到请求时，通过随机数做简单的负载均衡（利用多核特性）。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839const config = { headless: true, args: [ '--disable-gpu', '--disable-dev-shm-usage', '--disable-setuid-sandbox', '--no-first-run', '--no-sandbox', '--no-zygote', '--single-process', ],};const MAX_WSE = 4; // 启动几个浏览器const WSE_LIST = []; // 存储browserWSEndpoint列表init();// 初始化function init() { (async () =&gt; { for (let i = 0; i &lt; MAX_WSE; i++) { const browser = await puppeteer.launch(config); WSE_LIST[i] = await browser.wsEndpoint(); } })();}// 使用场景app.get('/', function (req, res) { const tmp = Math.floor(Math.random() * MAX_WSE); (async () =&gt; { const browserWSEndpoint = WSE_LIST[tmp]; const browser = await puppeteer.connect({ browserWSEndpoint }); const page = await browser.newPage(); await page.goto('http://example.com'); await page.screenshot({ path: 'example.png' }); await page.close(); res.send('Hello World!'); })();}); 最终代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** * @desc Puppeteer 实例 * 请求到达 -&gt; 连接 Chromium -&gt; 打开 tab 页 -&gt; 运行代码 -&gt; 关闭 tab 页 -&gt; 返回数据 * */import puppeteer from 'puppeteer';class PuppeteerHelper { constructor() { this.instance = null; // 启动4个浏览器 this.MAX_WSE = 4; // 存储browser.WSEndpoint列表 this.WSE_LIST = []; // puppeteer 配置 this.p_config = { headless: true, // 以 无头模式（隐藏浏览器界面）运行浏览器 args: [ '--disable-gpu', // GPU硬件加速 '--disable-dev-shm-usage', // 创建临时文件共享内存 '--disable-setuid-sandbox', // uid沙盒 '--no-first-run', // 没有设置首页。在启动的时候，就会打开一个空白页面。 '--no-sandbox', // 沙盒模式 '--no-zygote', '--single-process', // 单进程运行 ], }; // 初始化 this._init(); } static getInstance() { if (!this.instance) { this.instance = new PuppeteerHelper(); } return this.instance; } // 初始化 /** * @desc 初始化 * 使用puppeteer.connect比puppeteer.launch启动一个浏览器实例要快很多 * https://stackoverflow.com/questions/52431775/whats-the-performance-difference-of-puppeteer-launch-versus-puppeteer-connect * 当开启多个browser实例时，可以通过缓存wsEndpoint来达到复用的目的 * */ _init() { (async () =&gt; { console.log('【PuppeteerHelper】puppeteer config:', this.p_config); for (let i = 0; i &lt; this.MAX_WSE; i++) { // 先通过 puppeteer.launch() 创建一个浏览器实例 Browser 对象 const browser = await puppeteer.launch(this.p_config); // 存储浏览器 websocket 的地址 this.WSE_LIST[i] = await browser.wsEndpoint(); } console.log('【PuppeteerHelper】WSE_LIST：', this.WSE_LIST); })(); } /** * @desc 提供浏览器实例 * */ async _currentBrowser() { // 通过随机数做简单的负载均衡,确定使用的第几台浏览器 const tmp = Math.floor(Math.random() * this.MAX_WSE); const browserWSEndpoint = this.WSE_LIST[tmp]; console.log('【PuppeteerHelper】当前使用浏览器编号：%s ，wsEndpoint：%s', tmp, browserWSEndpoint); let browser; try { // 使用节点来重新建立连接 browser = await puppeteer.connect({ browserWSEndpoint }); } catch (err) { // 连接失败重新创建新的浏览器实例 browser = await puppeteer.launch(this.p_config); this.WSE_LIST[tmp] = browser.wsEndpoint(); console.log( '【PuppeteerHelper】当前使用浏览器编号：%s 连接失败，创建新实例，新的wsEndpoint：%s', tmp, this.WSE_LIST[tmp] ); console.log('【PuppeteerHelper】WSE_LIST：', this.WSE_LIST); } return browser; } /** * @desc 截图 * @param {string} url 网址链接 * @param {number} width 可视区域宽度，截图设定fullPage,可滚动，因此此设定可能对截图无意义 * @param {number} height 可视区域高度，截图设定fullPage,可滚动，因此此设定暂时对截图无意义 * */ async screenshot({ url, width = 800, height = 600 }) { // 获得可以使用的一台浏览器 const browser = await this._currentBrowser(); // 然后通过 Browser 对象创建页面 Page 对象 const page = await browser.newPage(); // 设置可视区域大小,默认的页面大小为800x600分辨率 await page.setViewport({ width, height }); // 然后 page.goto() 跳转到指定的页面 await page.goto(url, { // 不再有网络连接时触发（至少500毫秒后）,认为页面跳转完成 waitUtil: 'networkidle0', }); // 在浏览器环境中执行函数, 获取页面的宽度和高度 const documentSize = await page.evaluate(() =&gt; { return { width: document.documentElement.clientWidth, height: document.body.clientHeight, }; }); // 调用 page.screenshot() 对页面进行截图 const picture = await page.screenshot({ // 截图保存路径 path: './example.png', fullPage: true, // clip: { // x: 0, // y: 0, // height: documentSize.height, // width: documentSize.width // } }); // 关闭当前页面,减少内存的占用。 await page.close(); return picture; }}export default PuppeteerHelper.getInstance(); 使用 tab 方式渲染后请求速度提升了 200ms 左右，一个 tab 进程使用内存降到 20M 以内，带来的收益也非常可观。 不过这里要注意，官方并不建议这样做，因为一个 tab 页阻塞或者内存泄露会导致整个浏览器阻塞并 Crash。万全的解决办法是定期重启程序，当请求 1000 次或者内存超过限制后重启对应的进程。 过滤请求当我们使用puppeteer对页面异步渲染的dom结构进行解析时，往往需要等待页面完成渲染完成之后，才能使用脚本进行操作。但页面渲染过程中也包含了许多静态资源如：图片/音频/视频/样式文件等。此时我们可以通过page.setRequestInterception方法，对网页请求进行过滤，拦截静态资源的请求，加快页面渲染速度。 代码如下： 123456789101112// 开启请求拦截功能await page.setRequestInterception(true);page.on('request', (req) =&gt; { // 根据请求类型过滤 const resourceType = req.resourceType(); if (resourceType === 'image') { req.abort(); } else { req.continue(); }}); 推荐拦截的请求类型： 1234567891011121314151617181920212223const blockedResourceTypes = ['image', 'media', 'font', 'texttrack', 'object', 'beacon', 'csp_report', 'imageset'];const skippedResources = [ 'quantserve', 'adzerk', 'doubleclick', 'adition', 'exelator', 'sharethrough', 'cdn.api.twitter', 'google-analytics', 'googletagmanager', 'google', 'fontawesome', 'facebook', 'analytics', 'optimizely', 'clicktale', 'mixpanel', 'zedo', 'clicksor', 'tiqcdn',]; 代理请求除了过滤请求之外，我们也可用代理网页渲染过程中发出的请求。在某些爬虫项目达到不被发爬的目的， 代码如下： 1234567891011121314151617page.on('request', async (req) =&gt; { // 代理请求 const response = await fetch({ url: req.url(), method: req.method(), headers: req.headers(), body: req.postData(), agent: new HttpProxyAgent(getProxyIp()), }); // 响应请求 req.respond({ status: response.statusCode, contentType: response.headers['content-type'], headers: response.headers || req.headers(), body: response.body, });}); 参考链接 Puppeteer Puppeteer 自动化的性能优化与执行速度提升 puppeteer 优化小技巧","link":"/blogs/articles/2021/07/05/optimize-puppeteer/"},{"title":"RGB颜色插值渐变原理","text":"本文将要讲述 RGB 颜色插值渐变原理及其实现。 其实 RGB 颜色变换的原理就是线性插值。 例如将颜色RGB(0,0,0)变换为RGB(255,255,255)，其中要输出 100 次结果，则增加量就是(255-0)/100，将RGB分开计算也是一样。 同理，RGB(100,200,150)变换为RGB(255,0,255)，增加量的计算如下: 123R = (255 - 100) / 100 = 1.55;G = (0 - 200) / 100 = -2;B = (255 - 150) / 100 = 1.05; 这 100 个片段是有关增加量的递归结果，将片段连续播放，就形成了动画。 下面是一个用HTML5+JavaScript实现的 RGB 颜色插值渐变动画，在线DEMO 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;RGB Color Interpolation Gradient&lt;/title&gt; &lt;style&gt; body &gt; * { margin: 0 auto; width: 300px; } div { height: 300px; background-color: rgb(0, 0, 0); } input { display: block; width: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;R(&lt;span&gt;0&lt;/span&gt;):&lt;input type=&quot;range&quot; id=&quot;red&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;0&quot; /&gt;&lt;/p&gt; &lt;p&gt;G(&lt;span&gt;0&lt;/span&gt;):&lt;input type=&quot;range&quot; id=&quot;green&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;0&quot; /&gt;&lt;/p&gt; &lt;p&gt;B(&lt;span&gt;0&lt;/span&gt;):&lt;input type=&quot;range&quot; id=&quot;blue&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;0&quot; /&gt;&lt;/p&gt; &lt;p&gt;To RGB:&lt;input type=&quot;text&quot; value=&quot;255,255,255&quot; /&gt;&lt;button&gt;Animation&lt;/button&gt;&lt;/p&gt; &lt;script&gt; NodeList.prototype.forEach = Array.prototype.forEach; let rgb = [0, 0, 0]; let div = document.querySelector('div'); let inputs = document.querySelectorAll(&quot;input[type='range']&quot;); let toRGB = document.querySelector(&quot;input[type='text']&quot;); let button = document.querySelector('button'); let red = inputs[0]; let green = inputs[1]; let blue = inputs[2]; let lock = false; function change(i) { let span = inputs[i].parentElement.querySelector('span'); return function (e) { let value; if (e) { value = parseInt(e.target.value); span.innerHTML = value; rgb[i] = value; } else { value = parseInt(inputs[i].value); span.innerHTML = value; } div.style.backgroundColor = 'rgb(' + Math.round(rgb[0]) + ',' + Math.round(rgb[1]) + ',' + Math.round(rgb[2]) + ')'; }; } let redChange = change(0); let greenChange = change(1); let blueChange = change(2); red.addEventListener('change', redChange); green.addEventListener('change', greenChange); blue.addEventListener('change', blueChange); button.addEventListener('click', function () { if (lock) { return; } let finalValue = toRGB.value; let patternRGB = /^(([0-9])|([1-9]\\d)|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))[,](([0-9])|([1-9]\\d)|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))[,](([0-9])|([1-9]\\d)|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))$/; if (!patternRGB.test(finalValue)) { alert('Format is not correct, you should enter a value like 255,255,255'); return; } finalValue = finalValue.split(','); let rf = finalValue[0]; let gf = finalValue[1]; let bf = finalValue[2]; lock = true; red.disabled = true; green.disabled = true; blue.disabled = true; rgb[0] = Math.round(rgb[0]); rgb[1] = Math.round(rgb[1]); rgb[2] = Math.round(rgb[2]); let r = rgb[0]; let g = rgb[1]; let b = rgb[2]; let ri = (rf - r) / 100; let gi = (gf - g) / 100; let bi = (bf - b) / 100; setTimeout(function (i) { i = i || 1; rgb[0] += ri; rgb[1] += gi; rgb[2] += bi; red.value = rgb[0]; green.value = rgb[1]; blue.value = rgb[2]; redChange(); greenChange(); blueChange(); if (i &lt; 100) { let f = arguments.callee; setTimeout(function () { f(i + 1); }, 50); } else { lock = false; red.disabled = false; green.disabled = false; blue.disabled = false; } }, 0); }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/blogs/articles/2021/06/11/rgb-color-gradient-interpolation-principle-and-algorithm/"},{"title":"github-actions入门","text":"GitHub Actions 是 GitHub 的持续集成服务，于 2018 年 10 月推出。 GitHub Actions 简介GitHub Actions 帮助您自动完成软件开发周期内的任务。 GitHub Actions 是事件驱动的，意味着您可以在指定事件发生后运行一系列命令。 例如，每次有人为仓库创建拉取请求时，您都可以自动运行命令来执行软件测试脚本。 此示意图说明如何使用 GitHub Actions 自动运行软件测试脚本。事件会自动触发其中包作业的工作流程。 然后，作业使用步骤来控制操作运行的顺序。 这些操作是自动化软件测试的命令。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方！ GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName/repoName的语法引用 action。比如，actions/setup-node就表示github.com/actions/setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com/actions 里面。 既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。 actions123actions/setup-node@74bc508 # 指向一个 commitactions/setup-node@v1.0 # 指向一个标签actions/setup-node@master # 指向一个分支 基础概念GitHub Actions 有一些自己的术语。 workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 step（步骤）：每个 job 由多个 step 构成，一步步完成。 action （动作）：每个 step 可以依次执行一个或多个命令（action）。 虚拟环境GitHub 托管的运行器是由安装了 GitHub Actions 运行器应用程序的 GitHub 托管的虚拟机。 GitHub 提供使用 Linux、Windows 和 macOS 操作系统的运行器。 GitHub Ac­tions 为每个任务 (job) 都提供了一个虚拟机来执行，每台虚拟机都有相同的硬件资源： 2 核 CPU 7 GB RAM 内存 14 GB SSD 硬盘空间 虚拟环境 YAML 工作流程标签 Windows Server 2019 windows-latest 或 windows-2019 Ubuntu 20.04 ubuntu-20.04 Ubuntu 18.04 ubuntu-latest 或 ubuntu-18.04 Ubuntu 16.04 ubuntu-16.04 macOS Big Sur 11.0 macos-11.0 macOS Catalina 10.15 macos-latest 或 macos-10.15 注：Ubuntu 20.04 虚拟环境目前仅作为预览提供。 ubuntu-latest YAML 工作流程标签仍使用 Ubuntu 18.04 虚拟环境。 使用限制： 每个 workflow 的运行时限为 72 小时 每小时可以调用 1000 次 GitHub API 。 每个 job 最多可以执行 6 个小时。 免费版的用户最大支持 20 个 job 并发执行，macOS 最大只支持 5 个。 私有仓库 Linux 运行器每月累计使用时间为 2000 分钟，超过后$ 0.008/分钟，公共仓库则无限制。 注： 虽然名称叫持续集成，但当所有任务终止和完成时，虚拟环境内的数据会随之清空，并不会持续。即每个新任务都是一个全新的虚拟环境。 WorkflowGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml or .yaml，比如foo.yml or foo.yaml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml or .yaml文件，就会自动运行该文件。 workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段： name 工作流程的名称。 GitHub 在仓库的操作页面上显示工作流程的名称。 如果省略 name，GitHub 将其设置为相对于仓库根目录的工作流程文件路径。 name1name: GitHub Actions Demo on 必要 触发 workflow 的 GitHub 事件的名称。 你可以提供单一事件 string、事件的 array、事件 types 的 array 或事件配置 map，以安排工作流程的运行，或将工作流程的执行限于特定文件、标记或分支更改。 有关可用事件的列表，请参阅“触发工作流程的事件” 使用单一事件 Example using a single event1on: push 上面代码指定，push事件触发 workflow。 使用事件列表的示例 Example using a list of events1on: [push, pull_request] 上面代码指定，push事件或pull_request事件都可以触发 workflow。 完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。 on.&lt;push|pull_request&gt;.&lt;tags|branches&gt; 指定触发事件时，可以限定分支或标签。 1234on: push: branches: - master 上面代码指定，只有master分支发生push事件时，才会触发 workflow。 jobs workflow运行包括一项或多项jobs。 jobs默认是并行运行。 要按顺序运行作业，您可以使用 &lt;job_id&gt;needs 关键词在其他job上定义依赖项。 每个作业在 runs-on 指定的运行器环境中运行。 jobs.&lt;job_id&gt;.name workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。 jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。 12345jobs: my_first_job: name: My first job my_second_job: name: My second job 上面代码的jobs字段包含两项任务，job_id分别是my_first_job和my_second_job。 jobs.&lt;job_id&gt;.needs needs字段指定当前任务的依赖关系，即运行顺序。 123456jobs: job1: job2: needs: job1 job3: needs: [job1, job2] 上面代码中，job1必须先于job2完成，而job3等待job1和job2的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。 jobs.&lt;job_id&gt;.runs-on runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。 123- ubuntu-latest，ubuntu-18.04或ubuntu-16.04- windows-latest，windows-2019或windows-2016- macOS-latest或macOS-10.14 下面代码指定虚拟机环境为ubuntu-18.04。 1runs-on: ubuntu-18.04 jobs.&lt;job_id&gt;.steps steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。 123- jobs.&lt;job_id&gt;.steps.name：步骤名称。- jobs.&lt;job_id&gt;.steps.run：该步骤运行的命令或者 action。- jobs.&lt;job_id&gt;.steps.env：该步骤所需的环境变量。 下面是一个完整的 workflow 文件的范例。 workflow12345678910111213141516name: Greeting from Monaon: pushjobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 上面代码中，steps字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。 jobs.&lt;job_id&gt;.steps[*].uses 选择要作为job中step的一部分运行的操作。 操作是一种可重复使用的代码单位。 你可以使用工作流程所在仓库中、公共仓库中或发布 Docker 容器映像中定义的操作。 示例123456789steps: # Reference a specific commit - uses: actions/setup-node@74bc508 # Reference the major version of a release - uses: actions/setup-node@v1 # Reference a minor version of a release - uses: actions/setup-node@v1.2 # Reference a branch - uses: actions/setup-node@main 更多uses使用示例参考官网 示例一个简单的 workflow 文件示例workflow example123456789101112131415161718192021222324252627name: Hello Worldon: push: branches: - mainjobs: my_first_job: name: My first job runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@main - name: Run a single-line script run: echo &quot;Hello World!&quot; my_second_job: name: My second job runs-on: macos-latest steps: - name: Run a multi-line script env: MY_VAR: Hello World! MY_NAME: P3TERX run: | echo $MY_VAR echo My name is $MY_NAME 上面这个 workflow 文件的要点如下。 整个流程在main分支发生push事件时触发。 有两个个job，一个运行在虚拟机环境ubuntu-latest。一个运行在macos-latest My First Job 第一步是获取源码，使用的 action 是actions/checkout。 第二步是运行一个简单的脚本：echo &quot;Hello World!&quot; My Second Job 设定环境变量 MY_VAR 和MY_NAME 运行脚本打印环境变量 保存上面的文件后，将整个仓库推送到 GitHub。 GitHub 发现了 workflow 文件以后，就会自动运行。你可以在网站上实时查看运行日志，日志默认保存 30 天。 示例文件运行截图： react 项目发布到 Github Pages示例项目需要将构建成果发到 GitHub 仓库，因此需要 GitHub 密钥。按照官方文档，生成一个密钥。然后，将这个密钥储存到当前仓库的Settings/Secrets里面。 在这个仓库的.github/workflows目录，生成一个 workflow 文件，名字可以随便取，这个示例是react-cli.yml。 我们选用一个别人已经写好的 action：JamesIves/github-pages-deploy-action，它提供了 workflow 的范例文件，直接拷贝过来就行了（查看源码） react-cli123456789101112131415161718192021222324name: github-test-actions上的React项目部署到github pageson: push: branches: - react-branchjobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout 🛎️ uses: actions/checkout@v2 with: persist-credentials: false - name: Install and Build 🔧 run: | npm install npm run build - name: Deploy 🚀 uses: JamesIves/github-pages-deploy-action@3.7.1 with: ACCESS_TOKEN: ${{ secrets.REACT_WORKFLOW_TOKEN }} BRANCH: gh-pages # The branch the action should deploy to. FOLDER: build # The folder the action should deploy. 整个流程在react-branch分支发生push事件时触发。 只有一个job，运行在虚拟机环境ubuntu-latest。 第一步是获取源码，使用的 action 是actions/checkout。 第二步是安装与构建。 第三步是部署，使用的 action 是JamesIves/github-pages-deploy-action，使用三个变量，分别为 GitHub 密钥、发布分支、构建成果所在目录。其中，只有 GitHub 密钥是变量，需要写在双括号里面，其他三个都可以直接写在文件里。 保存上面的文件后，将整个仓库推送到 GitHub。 等到 workflow 运行结束，访问 GitHub Page，会看到网页已经部署到指定网址上了。 参考链接 GitHub Actions GitHub Actions 入门教程 GitHub 托管的运行器的规格 GitHub 使用限制、计费和管理 GitHub 操作的工作流程语法 五分钟了解 YAML actions/checkout github-pages-deploy-action","link":"/blogs/articles/2021/01/06/start-github-actions/"},{"title":"终端如何挂代理","text":"本文将介绍终端是如何挂代理的。 前提首先你需要类似于shadowsocksX-NG-R8的代理软件，本文以shadowsocksX-NG-R8为例 正文打开shdowsocks为代理模式。 以zsh作为说明 .zshrc1$ vim ~/.zshrc 第一种： 添加如下代理配置: edit12345678910111213# where need proxyproxy () { export http_proxy=&quot;socks5://127.0.0.1:1086&quot; export https_proxy=&quot;socks5://127.0.0.1:1086&quot; echo &quot;Socks Proxy on&quot;}# where need noproxynoproxy () { unset http_proxy unset https_proxy echo &quot;Socks Proxy off&quot;} 第二种： edit123# proxy listalias proxy='export all_proxy=socks5://127.0.0.1:1086'alias noproxy='unset all_proxy' 注：两种方式皆可，127.0.0.1:1086取自高级设置 :wq保存退出 .zshrc1$ source ~/.zshrc 验证是否proxy成功: 12345678910$ curl cip.ccIP : 101.81.77.200地址 : 中国 上海运营商 : 电信数据二 : 上海市 | 电信数据三 :URL : http://www.cip.cc/101.81.77.200 执行proxy: 1$ proxy 123456789$ curl cip.ccIP : 42.200.244.149地址 : 中国 香港 pccw.com数据二 : 香港 | 电讯盈科商用网络数据三 : 中国香港 | 电讯盈科URL : http://www.cip.cc/42.200.244.149 如果cip.cc不能用，可以换个类似的站点查询 如果不需要走代理，执行： 123$ noproxy$ curl cip.ccIP : 101.81.77.200 参考链接 Mac OSX 终端走 shadowsocks 代理 #18","link":"/blogs/articles/2021/04/02/terminal-proxy/"},{"title":"uPic 图床配置教程 - Github","text":"简介uPic(upload Picture) 是一款 Mac 端的图床(文件)上传客户端，可将图片、各种文件上传到配置好的指定提供商的对象存储中。然后快速获取可供互联网访问的文件 URL。 配置项说明 用户名: Github 用户名。例如：我的 Github 主页https://github.com/MrSeaWave ，我的用户名就是MrSeaWave 仓库名: 需要储存上传文件的仓库名称。例如：我的仓库地址为https://github.com/MrSeaWave/figure-bed-profile ，仓库名称就是figure-bed-profile 分支: 分支名称，默认是main，如果是其他分支，就必须先创建好分支，才能上传 Token: Github 的个人访问令牌（Personal access tokens） 域名: 默认可不设置域名，会使用 Github 默认的访问地址。当你的仓库开启了pages功能，并配置好了自定义域名时，这里就可以使用你的自定义域名 使用默认 CDN 加速访问: 勾选时会自动使用 jsdelivr CDN 进行加速访问 保存路径: 文件储存的路径（包括文件夹）。 支持 {year} {month} {day} {hour} {minute} {second} {since_second} {since_millisecond} {random} {filename} {.suffix} 等变量。比如：上传的图片为 uPic.jpg，设定为 “uPic/{filename}{.suffix}”，则会保存到 “uPic/uPic.jpg”。 Token 获取方式 进入Github Token 创建页面 勾选 repo 访问权限。然后滚动页面到底部，点击Generate token按钮来生成 token。 复制生成好的 Token 值到 uPic token 输入框。注意：此 Token 只会显示一次！请务必保存好，否则之后丢失了，就得重新创建了。 最终效果保存一下，在菜单栏-图床栏选中刚刚配置好的 Github 图床，上传一张图片试试吧。上传成功后，Github 仓库就会出现你刚上传的文件啦","link":"/blogs/articles/2021/03/24/upic-github/"},{"title":"vs-code“实用插件”","text":"在使用vs-code时，整理了一些好用的vs-code插件分享。 基础必备Chinesevscode编辑器汉化包，安装后，在 locale.json 中添加 &quot;locale&quot;: &quot;zh-cn&quot;，即可载入中文（简体）语言包。 Auto Rename Tag自动重命名成对的HTML标记，修改开始标签，结束标签会同步修改。 Auto Close Tag自动闭合HTML/XML标签 HTML SnippetsHTML 代码片段，该插件可为你提供 html 标签的代码提示，不用键入尖括号了。 Bracket Pair Colorizer该插件可以为你把成对的括号做颜色区分，并且提供一根连接线。方便我们审阅代码结构。 CSS Peekcss 样式查看器，可快速查看我们的 css 样式，非常方便快捷。 Npm Intellisense可自动完成导入语句中的 npm 模块。 open in browser快速打开html文件到浏览器预览。 Debugger for Chrome调试工具，必装；具体使用查看官网 vscode-icons提供了非常漂亮的目录树图标主题。 Material Icon Theme提供了非常漂亮的目录树图标主题。（这款最爱。 Atom One Dark ThemeOne Dark Theme based on Atom。 Dracula Official吸血鬼主题。 Path Intellisense自动提示文件路径，支持各种快速引入文件。 Image preview鼠标悬浮在链接上可及时预览图片。 Highlight Matching Tag点击某 Tag 时对应的 Tag 下会有下划线标示，比较实用； Beautify在代码文件右键鼠标一键格式化 html,js,css JavaScript (ES6) code snippetsES6 语法智能提示，以及快速输入。 VeturVScode官方钦定 Vue 插件，Vue开发者必备。内含语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger等实用功能。 indent-rainbow用颜色填充缩进，非常直观，如果有缩进错误还会变成红色。（ 对写 Nim or Python 用处极大。 代码风格规范Prettier - Code formatterPrettier 是一个“有态度”的代码格式化工具。，prettier支持我们大前端目前大部分语言处理，包括JavaScript 、Flow、 TypeScript 、CSS 、SCSS 、Less 、JSX 、Vue 、GraphQL 、JSON 、Markdown ESlint规范 js 代码书写规则，如果觉得太过严谨，可自定义规则。 Code Spell Checker是拼写检查程序，检查不常见的单词，如果单词拼写错误，会给出警告提示。 koroFileHeader在vscode中用于生成文件头部注释和函数注释的插件，经过多版迭代后，插件：支持所有主流语言，功能强大，灵活方便，文档齐全，食用简单！ Better Align代码书写的整洁，工整往往是衡量一个程序员素养的标准，这款插件可以让你的代码更排版优雅。 change-case通常我们对一个变量的命名可能是驼峰，可能是全大写，又或是下划线，这里可通过这个插件解决变量命名规范的问题。 选中变量配合组合键[Command+Shift+p]，输入对应格式即可。 1234567891011121314151617extension.changeCase.commands：列出所有“更改案例”命令，如果仅选择一个单词，则带有预览extension.changeCase.camel：更改大小写'camel'：转换为字符串，并用下一个字母大写表示分隔符extension.changeCase.constant：更改大小写“常量”：转换为大写字母，下划线分隔字符串extension.changeCase.dot：更改大小写的“点”：转换为小写，句点分隔的字符串extension.changeCase.kebab：更改大小写“ kebab”：转换为小写字母，用破折号分隔的字符串（参数名的别名）extension.changeCase.lower：更改大小写为“小写”：转换为小写的字符串extension.changeCase.lowerFirst：更改大小写“ lowerFirst”：转换为首字母小写的字符串extension.changeCase.no：转换没有任何大小写的字符串（小写字母，空格分隔）extension.changeCase.param：更改大小写为'param'：转换为小写字母，用破折号分隔的字符串extension.changeCase.pascal：更改大小写“ pascal”：转换为以与camelCase相同的方式表示的字符串，但首字母也大写extension.changeCase.path：更改大小写的“路径”：转换为小写，用斜杠分隔的字符串extension.changeCase.sentence：更改大小写的“句子”：转换为小写的空格分隔的字符串extension.changeCase.snake：更改大小写“ snake”：转换为小写字母，下划线分隔字符串extension.changeCase.swap：更改大小写“交换”：转换为每个大小写相反的字符串extension.changeCase.title：更改大小写“标题”：转换为以空格分隔的字符串，每个单词的第一个字符均大写extension.changeCase.upper：更改大小写为大写：转换为大写字符串extension.changeCase.upperFirst：更改大小写为“ upperFirst”：转换为首字母大写的字符串 Better Comments丰富注释颜色，让注释也具有生命力，如需自定义样式，需要写入配置代码。 1234567891011配置代码&quot;better-comments.tags&quot;: [ { &quot;tag&quot;: &quot;*&quot;, &quot;color&quot;: &quot;#98C379&quot;, &quot;strikethrough&quot;: false, &quot;backgroundColor&quot;: &quot;transparent&quot; }]使用// * 绿色的高亮注释 TODO Tree我们经常会在代码中使用TODO来标记我们的代码，提高可读性，TODO Tree这款插件提供了可视化窗口来查看和管理我们的TODO Tree 其他插件（开发神器GitLensGitLens可以帮助你更好地理解代码。快速查看更改行或代码块的对象，功能强大，功能丰富且高度可定制，可以满足你的需求 GitHistoryGitHistory可查看和搜索 git 日志以及图形和详细信息，同时还支持分支比较，分支管理等操作，非常方便。 Partial Diff文件比较是一个很常见的场景，如果光凭我们肉眼分别的话，累人不说还容易出错。 Partial Diff的出现就正好解决了这个问题。 Markdown All in One这款神器可以让我们在vscode里面快乐的书写Markdown，功能强大。提供了丰富的快捷键，可边写边看，轻松转化为html或pdf文件，十分好用，强烈推荐。 vscode-drawio这款神器可以让我们在vscode里面快乐的画流程图。新建 .drawio 后缀文件并拖入 vscode 中。 Polacode-2020这款神器可以将我们的代码转化成一张逼格满满的图片，在写文章或者代码分享的时候。抛出一张这样的图片，可比随手截图体面多了。 carbon-now-sh也是一款将代码转换成图片的插件，不过它会打开carbon.now.sh网站 REST Client这款神器可以让我们在vscode里面进行接口调试，提供丰富的 api 配置方式，让我们不用离开编辑器也可以随时调用接口调试。 新建一个.http文件，写下基本的测试代码，点击 Send Request即可在右边窗口查看接口返回结果，非常 nice。 Browser Preview可以让我们在vscode里面打开浏览器，一边编码一边查看。 JavaScript Booster这款神器可以在我们代码写的不规范或者有待调整的地方，在光标聚焦后，会有一个小灯泡，只需跟随灯泡 💡，会提示对应的不合理原因和改进方案，极大的提高了我们的代码优雅度。 当在JavaScript（或TypeScript / Flow）中编辑代码时，此VS Code扩展提供了各种代码操作（快速修复）。只需注意左侧的灯泡 💡，然后按一下它即可了解如何在光标下转换代码。 Settings Sync让我们的vscode配置同步到云端，当我们跟换电脑或者再次安装vscode的时候，只需要登录账号即可同步配置了，而不用再次从头开始。（针对老版本的vscode） 预览版vscode自带配置同步功能，可以通过 Microsoft 账户或 GitHub 账户进行多机器同步。具体可参考官网 Vim如果你是vim重度用户，那么这款插件必不可少。 Live Share可以使您能够与他人实时进行协作式编辑和调试，无论您使用的是哪种编程语言或正在构建的应用程序类型。具体使用细节可查看官网 Remote Development远程开发必备扩展安装（划时代的产品）。会为你安装包括 Remote-SSH 等全部远程开发使用的扩展。具体搭建可参考VS Code Remote 环境搭建","link":"/blogs/articles/2021/03/15/vs-code-plugins/"},{"title":"vscode插件project-manager使用","text":"在项目开发的时候，我们经常需要同时操作多个项目，经常需要切换项目。 以前的方式 在工具栏中点击文件，打开，选择本地项目的目录 / 新建窗口 如果有最近打开的项目，点击打开最近的文件 这两种方式对于需要经常切换项目时，比较耗时 为解决这个问题，VSCode 提供了 Project Manager 插件管理，开发时常用的项目。 Project Manager 管理项目可用命令 Project Manager: Save Project 将当前文件夹另存为新项目 Project Manager: Edit Project 手动编辑项目（projects.json） Project Manager: List Projects to Open 列出所有已保存/检测到的项目并选择一个 Project Manager: List Projects to Open in New Window 列出所有已保存/检测到的项目，然后选择一个在新窗口中打开 Project Manager: Refresh Projects 刷新缓存的项目 保存项目command+ shift + p 打开配置文件，输入 Project Manager: Save Projects 您可以随时将当前项目保存在管理器中。你只需要输入一个名字。它甚至会自动为你建议一个名字:) 按 Enter 键后，右下角弹出保存成功提示。 编辑项目为了更轻松地自定义项目列表，您可以 projects.json 直接在 Code 中编辑文件。只需执行 Project Manager: Edit Projects和projects.json 文件被打开。这很简单，我就手动添加了一个 blogs 项目： 确保 JSON 文件格式正确。否则，项目管理器将无法打开它，并且会出现类似这样的错误消息。在这种情况下，您应该使用 Open File 按钮来修复它。 刷新项目command+ shift + p 打开配置，输入 Project Manager: Refresh Projects 刷新项目 项目列表刷新之后，左侧导航栏，多出一个文件夹图标，用于管理项目，点击其中一个，自动切换项目。 可用设置设置插件的可配置项，在 首选项 - 设置 - 拓展 - Project Manager Configuration 位置 举例：您可以选择项目的排序方式 1&quot;projectManager.sortList&quot;: &quot;Name&quot; Saved：您保存项目的顺序 Name：您为项目键入的名称 Path：项目的完整路径 Recent：最近使用的项目","link":"/blogs/articles/2021/03/31/vscode-project-manager/"},{"title":"前端页面添加水印","text":"为防止信息泄露，给网页加水印是一种常见的方法。本篇文章将介绍一种添加明水印的方法。 给页面指定标签添加水印背景，原理是 canvas 画图，canvas.toDataURL()转成 base64 数据，动态添加到标签的 background。 特点： 不影响现有代码 可以任意给网页的不同部分添加水印 纯前端 js 实现 可简单防止用户通过浏览器开发者工具隐藏水印 生成水印生成水印单个图片水印的特点是，包含一段标识信息，同时需要覆盖足够的区域，很自然想到可以用 background，指定image，并让它在x,y 2 个方向上重复展示。 用canvas把信息画成图之后，调用toDataURL()方法就可以得到一个 url，该 url 实际包含了 Base64 过的图像信息，可以直接用在background上 代码示例如下： 123456789101112131415161718192021// 创建水印背景图片function createImageUrl(options) { const canvas = document.createElement('canvas'); const text = options.text; canvas.width = options.width; canvas.height = options.height; const ctx = canvas.getContext('2d'); ctx.shadowOffsetX = 2; // X轴阴影距离，负值表示往上，正值表示往下 ctx.shadowOffsetY = 2; // Y轴阴影距离，负值表示往左，正值表示往右 ctx.shadowBlur = 2; // 阴影的模糊程度 // ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; //阴影颜色 ctx.font = options.font; ctx.fillStyle = options.fontColor; ctx.rotate(options.rotateDegree); ctx.translate(options.translateX, options.translateY); ctx.textAlign = 'left'; // 在 (x, y)位置填充实体文本 ctx.fillText(text, 35, 32); return canvas.toDataURL('image/png');} 设置背景将上面得到的图片放在某个div的background上，这里需要注意的是： position: fixed: 这样可以保证不管内容如何滚动，水印都能显示； pointer-events: none: 阻止水印影响页面内容 动态计算出水印的位置 代码示例如下： 123456789101112131415161718192021222324252627282930// 将背景填充至指定水印位置处function createContainer(options, forceCreate) { const oldDiv = document.getElementById(options.id); if (!forceCreate &amp;&amp; oldDiv) return container; const url = createImageUrl(options); const div = oldDiv || document.createElement('div'); div.id = options.id; // 水印容器的父元素，默认document.body let parentEl = options.preventTamper ? document.body : options.parentEl || document.body; if (typeof parentEl === 'string') { if (parentEl.startsWith('#')) parentEl = parentEl.substring(1); parentEl = document.getElementById(parentEl); } // 返回元素的大小及其相对于视口的位置。 const rect = parentEl.getBoundingClientRect(); // 默认：按照父元素的偏移位置 options.style.left = (options.left || rect.left) + 'px'; options.style.top = (options.top || rect.top) + 'px'; div.style.cssText = getStyleText(options); div.setAttribute('class', ''); div.style.background = 'url(' + url + ') repeat top left'; !oldDiv &amp;&amp; parentEl.appendChild(div); return div;} 防止客户端篡改截止到上面为止，水印可以正常显示了，但这样只能防止小白用户，稍微有点技术的用户就知道，可以用浏览器的开发者工具来动态更改dom，比如display: none；就可以隐藏水印；所以还需要加一点机制防止用户进行篡改；当然，从本质上来说是没有绝对的办法在客户端去防用户的，所以这里只是增加了用户篡改的难度。 1. 不间断比较 div 的值监测水印 div 的变化，一旦发生变化，则重新生成水印。 记录刚生成的 div 的innerHTML，每隔几秒就取一次新的值，通过比较两者的md5，如果发生变化则重新生成。但这个方法有几个缺点： 滞后性，修改不能马上被监测后；而如果间隔时间过短，则可能影响性能； 生成md5也有不小的开销，特别是打开多个页面的时候； 所以这种方法不可行。 2. MutationObserver使用浏览器提供的一种监测元素变化的 API：MutationObserver 代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 监听元素function observe(options, observeBody) { observeWatermark(options); observeBody &amp;&amp; observeBodyElement(options);}// 监听水印function observeWatermark(options) { const target = container; const childCallBack = () =&gt; { // 关闭上个观察，重新创建元素，重新观察 observer.disconnect(); container = createContainer(options, true); observer.observe(target, observeConfig); }; observer = new MutationObserver(childCallBack); // 开始观察目标节点 observer.observe(target, observeConfig);}// 监听body元素，如果水印element被删除，则重新创建&amp;&amp;重新监听function observeBodyElement(options) { const callback = (mutations) =&gt; { mutations.forEach((m) =&gt; { if (m.type === 'childList' &amp;&amp; m.removedNodes.length &gt; 0) { let watermarkNodeRemoved = false; for (const n of m.removedNodes) { if (n.id === options.id) { watermarkNodeRemoved = true; } } if (watermarkNodeRemoved) { container = createContainer(options); observe(options, false); } } }); }; const pObserver = new MutationObserver(callback); pObserver.observe(document.body, { childList: true, subtree: true });} MutationObserver 只能监测到诸如属性改变、增删子结点等，对于自己本身被删除，是没有办法的；这里通过同时监测父结点，看 div 是否被删除来解决这个问题的。 最终代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156// 默认配置const defaultOption = { id: 'watermark-id', // parentEl: '', // 防止别人外界破坏 preventTamper: false, // 水印单个图片配置 width: 110, height: 80, text: 'watermark', font: '20px Times New Roman', fontColor: 'rgba(204,204,204,0.45)', // 顺时针旋转的弧度 rotateDegree: (30 * Math.PI) / 180, // 平移变换 translateX: 0, translateY: 0, // 水印容器的样式 style: { 'pointer-events': 'none', width: '100%', height: '100%', top: 0, left: 0, position: 'fixed', 'z-index': 1000, },};// 观察配置const observeConfig = { attributes: true, childList: true, characterData: true, subtree: true,};let container;let observer;// 创建水印背景图片function createImageUrl(options) { const canvas = document.createElement('canvas'); const text = options.text; canvas.width = options.width; canvas.height = options.height; const ctx = canvas.getContext('2d'); ctx.shadowOffsetX = 2; // X轴阴影距离，负值表示往上，正值表示往下 ctx.shadowOffsetY = 2; // Y轴阴影距离，负值表示往左，正值表示往右 ctx.shadowBlur = 2; // 阴影的模糊程度 // ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; //阴影颜色 ctx.font = options.font; ctx.fillStyle = options.fontColor; ctx.rotate(options.rotateDegree); ctx.translate(options.translateX, options.translateY); ctx.textAlign = 'left'; // 在 (x, y)位置填充实体文本 ctx.fillText(text, 35, 32); return canvas.toDataURL('image/png');}// 将背景填充至指定水印位置处function createContainer(options, forceCreate) { const oldDiv = document.getElementById(options.id); if (!forceCreate &amp;&amp; oldDiv) return container; const url = createImageUrl(options); const div = oldDiv || document.createElement('div'); div.id = options.id; // 水印容器的父元素，默认document.body let parentEl = options.preventTamper ? document.body : options.parentEl || document.body; if (typeof parentEl === 'string') { if (parentEl.startsWith('#')) parentEl = parentEl.substring(1); parentEl = document.getElementById(parentEl); } // 返回元素的大小及其相对于视口的位置。 const rect = parentEl.getBoundingClientRect(); // 默认：按照父元素的偏移位置 options.style.left = (options.left || rect.left) + 'px'; options.style.top = (options.top || rect.top) + 'px'; div.style.cssText = getStyleText(options); div.setAttribute('class', ''); div.style.background = 'url(' + url + ') repeat top left'; !oldDiv &amp;&amp; parentEl.appendChild(div); return div;}// 获取配置中的stylefunction getStyleText(options) { let ret = ''; const style = options.style; Object.keys(style).forEach((k) =&gt; { ret += k + ': ' + style[k] + ';'; }); return ret;}// 监听元素function observe(options, observeBody) { observeWatermark(options); observeBody &amp;&amp; observeBodyElement(options);}// 监听水印function observeWatermark(options) { const target = container; const childCallBack = () =&gt; { // 关闭上个观察，重新创建元素，重新观察 observer.disconnect(); container = createContainer(options, true); observer.observe(target, observeConfig); }; observer = new MutationObserver(childCallBack); // 开始观察目标节点 observer.observe(target, observeConfig);}// 监听body元素，如果水印element被删除，则重新创建&amp;&amp;重新监听function observeBodyElement(options) { const callback = (mutations) =&gt; { mutations.forEach((m) =&gt; { if (m.type === 'childList' &amp;&amp; m.removedNodes.length &gt; 0) { let watermarkNodeRemoved = false; for (const n of m.removedNodes) { if (n.id === options.id) { watermarkNodeRemoved = true; } } if (watermarkNodeRemoved) { container = createContainer(options); observe(options, false); } } }); }; const pObserver = new MutationObserver(callback); pObserver.observe(document.body, { childList: true, subtree: true });}// 入口函数function init(options) { options = !options ? defaultOption : { ...defaultOption, ...options }; container = createContainer(options); options.preventTamper &amp;&amp; observe(options, true);}init({ preventTamper: true }); 最终效果如下： 参考链接 前端页面动态添加水印 给网页加水印 Canvas API CanvasRenderingContext2D MutationObserver","link":"/blogs/articles/2021/07/09/watermark/"},{"title":"webpack import() 动态加载模块踩坑","text":"本文是关于 webpack 中使用 import 时的踩坑记录。 webpack 根据 ES2015 loader 规范实现了用于动态加载的import()方法。 这个功能可以实现按需加载我们的代码，并且使用了promise式的回调，获取加载的包。 在代码中所有被import()的模块，都将打成一个单独的包，放在chunk存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载。 demo 如下： 1234 import('lodash').then((_) =&gt; { // Do something with lodash (a.k.a '_')... });} 可以看到，import()的语法十分简单。该函数只接受一个参数，就是引用包的地址，这个地址与 es6 的 import 以及 CommonJS 的 require 语法用到的地址完全一致。可以实现无缝切换。 然而在开发时为了偷懒省事，很喜欢封装部分插件：(这里使用了react-loadable来简化组件的懒加载封装) 12345678const LazyLoad = (path) =&gt; { return Loadable({ loader: () =&gt; import(path), loading: Loading, });};const B = LazyLoad('./b.js'); 然后开心的在代码中写上LazyLoad('./pages/xxx')。果不其然，挂了，收获了报错： 这是因为 webpack 编译的时候 import 预发，**不支持动态路径!!!**因为 webpack 需要先扫一遍 js 文件，找出里面按需加载的部分，进行按需打包，但不会关心内部的 js 执行上下文，也就是说，在 webpack 扫描的时候，js 中的变量并不会计算出结果，所以 import 不支持动态路径。 如： 1import('./app'+path+'/util') =&gt; /^\\.\\/app.*\\/util$/ import 参数中的所有变量，都会被替换为【.*】，而 webpack 就根据这个正则，查找所有符合条件的包，将其作为 package 进行打包。具体可查看官方 因此，如果我们直接传入一个变量，webpack 就会把 (整个电脑的包都打包进来) 认为你在逗他，并且抛出一个 WARNING: Critical dependency: the request of a dependency is an expression。 所以 import 的正确姿势，应该是尽可能静态化表达包所处的路径，最小化变量控制的区域。 如我们要引用一堆页面组件，可以使用import('./pages/'+ComponentName)，这样就可以实现引用的封装，同时也避免打包多余的内容。 另外一个影响功能封装的点，是import()中的相对路径，是import语句所在文件的相对路径，所以进一步封装 import 时会出现一些麻烦。 因为import语句中的路径会在编译后被处理成webpack命令执行目录的相对路径。 所以： 既然 import 不能搞，那只能封装非 import 的部分： 12345678const LazyLoad = (loader) =&gt; Loadable({ loader, loading: Loading, });const B = LazyLoad(() =&gt; import('./b.js'));const C = LazyLoad(() =&gt; import('./c.js')); 参考文档 webpack 脑阔疼的 webpack 按需加载 webpack import() 动态加载模块踩坑","link":"/blogs/articles/2021/06/23/webpack-import/"},{"title":"hexo new 生成新的文章","text":"介绍关于如何新建博客，官网已经有了明确的介绍： 你可以执行下列命令来创建一篇新文章或者新的页面。 命令行1$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 这句话有几个地方需要解释一下： layout是什么？layout的意思是布局，hexo博客安装成功后，在默认的根部录下，有一个scaffolds文件夹，里面有个 3 个文件，分别是draft.md,page.md,post.md。这 3 个文件就是默认的 layout 。这三个布局分别会有什么样的作用和效果，我们会在后面的内容中进行详细说明。 如果不提供 layout 的话，也可以生成博客，不过默认的 layout 是在 _config.yml 中的配置。一般情况下，如果没有更改过任何 _config.yml 中的内容的话，默认的 layout 是 post 如果 title 包含空格的话， title 需要用引号包裹起来。也就是意味着，如果 title 没有空格的话，可以不使用引号。 假设我们想要写一篇名为 myBlog 的博客，如果输入完整的命令的话，应该是： hexo new post &quot;myBlog&quot;。但是因为默认情况下，我们的 layout 就是post，所以我们可以将 post 省略掉，写为 hexo new &quot;myBlog&quot; 。又因为我们的博客名字中没有空格，因此可以将省略号去掉，写为hexo new myBlog。这个命令已经是简化到不能再简化的命令了。而如果我们的博客名称是 my first blog，因为名称包含了空格，所以我们的命令就必须将博客名称包裹起来，也就是说最简化的命令就是 hexo new &quot;my first blog&quot; 。 这就是为什么很多网上的攻略说新生成一篇文章时用hexo new &lt;title&gt;的命令的原因，这个命令没错，但是只是大部分的情况，而不是完整的命令。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts layout 为 post 的情况以上面的情况为例，我们的命令是 hexo new post myBlog ，执行这个命令之后，你会发现命令行会有如下提示： 它告诉你，在根目录的下的 source 文件夹中创建了一个 _post 文件夹，并且在内生成了一个myBlog.md的文件。打开对应的文件夹，你会发现myBlog.md的文件，这就是你新生成的文件。你可以通过某种支持markdown的编辑器打开这个文件，然后使用markdown格式的方法书写这篇博客。 layout 为 draft 的情况Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹。 接下来我们使用hexo new draft myDraftBlog，生成myDrafaBlog.md文件，这个 md 文件是草稿状态，也就是说，这篇文章仅仅是作为你的草稿而不是正式稿，所以不会发表在博客主页上。草稿就是需要你不断完善的文章，知道有一天你觉得这篇文章可以正式发表了，你可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定layout 来指定布局。 publish1$ hexo publish [layout] &lt;title&gt; （草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。） 执行hexo publish draft myDraftBlog，你就会发现，source/_draft文件夹下的myDraftBlog.md文件消失了，而在_post文件夹下你会找到myDraftBlog.md文件。 layout 为 page 的情况我们可以尝试一下下面这个命令hexo new page &quot;about&quot;，这个时候你打开source文件夹你会发现一个about的文件夹，里面会有一个index.md的文件。打开http://localhost:4000/about，这个时候你就会发现你刚才编辑的 index.md 的内容会出现在这里。 layout 为 page的时候，其实就是相当于生成一个新的路径，也就是我们说的url的path，或者也可以称作路由。通过这种方式，我们可以把我们的博客再进行细分各个内容版块，更有条理的组织我们的博客。 Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： eg1234---title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签 （不适用于分页） categories 分类 （不适用于分页） permalink 覆盖文章网址 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 eg12345categories: - Diarytags: - PS3 - Games 如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。 分类Eg1234categories: - [Diary, PlayStation] - [Diary, Games] - [Life] 此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。 标签插件具体内容参考官网 参考链接 hexo 写作","link":"/blogs/articles/2021/01/05/writing-hexo/"},{"title":"微信小程序云开发获取用户手机号","text":"在网上搜索时，大部分微信小程序云开发获取手机号码的例子还都是需要通过code获取session_key来解密信息取得手机号码，总感觉哪里不对，官网上都已经说过，云开发是自动鉴权的，不应该还要解密,因此下面介绍如何使用云开发获取用户信息数据。 具体步骤1，页面 cellphone.wxml cellphone.wxml1&lt;button open-type=&quot;getPhoneNumber&quot; bindgetphonenumber=&quot;getPhoneNumber&quot;&gt;&lt;/button&gt; 2，文件cellphone.js cellphone.js12345678910111213141516Page({ getPhoneNumber(e) { console.log(e.detail); wx.cloud .callFunction({ name: 'openapi', data: { action: 'getcellphone', id: e.detail.cloudID, }, }) .then((res) =&gt; { console.log('res: ', res); }); },}); 3，云函数 openapi 的index.js index.js123456789101112131415161718192021// 云函数入口文件const cloud = require('wx-server-sdk');cloud.init();// 云函数入口函数exports.main = async (event, context) =&gt; { switch (event.action) { case 'getcellphone': { return getCellphone(event); } default: { return; } }};async function getCellphone(event) { const res = await cloud.getOpenData({ list: [event.id], }); return { res, event };} 调用后res数据如下 res123456789101112131415161718{ &quot;list&quot;: [ { &quot;cloudID&quot;: &quot;***********&quot;, &quot;data&quot;: { &quot;phoneNumber&quot;: &quot;****&quot;, // 用户绑定的手机号（国外手机号会有区号） &quot;purePhoneNumber&quot;: &quot;******&quot;, // 没有区号的手机号 &quot;countryCode&quot;: &quot;86&quot;, // 区号 &quot;watermark&quot;: { &quot;timestamp&quot;: 1612332238, &quot;appid&quot;: &quot;********&quot; } } } ], &quot;errMsg&quot;: &quot;getOpenData:ok&quot;, &quot;errCode&quot;: 0} 全程不涉及code,session_key和加密解密啥事，即可获取到用户的手机号。 参考链接 微信小程序云开发获取手机号码 获取手机号| 微信开放文档 - 微信开放社区 - 腾讯 Cloud.getOpenData(list: string[]): Object","link":"/blogs/articles/2021/02/03/wx-get-cellphone/"},{"title":"GoodNotes软件","text":"今天安利一款软件：GoodNotes 想必手头上有 ipad 的人可能或多或少都听过他的大名，没错，他就是可以让你的 Ipad 不在是娱乐工具，从而转型为学术型工具的一款基于 Apple Pencil 的电子笔记的软件。 大家在看书，学习，玩游戏时或多或少都需要笔记功能，可以说笔记在两个环节起作用： 方便记录过后的查阅。书写过程怎么记的也许不重要，事后方便查找翻看才是王道； 追求笔记书写的过程。有些笔记记完了甚⾄不⼀定会回去看，但是⼀笔⼀画写下来的过程能加深记忆。 对于第一类笔记，我会使用键盘或者语音输入从而尽快完成记录； 对于第二类笔记，则使用手写形式的电子笔记。比如看书，计算公式，学习语言，需要花时间反复去记忆，那么手写这种看似很慢的方式，反而很高效。相比于噼里啪啦在屏幕上打字，一笔一画写字的过程也是记忆和思考的过程。即使后期不去回看，学习效果也比打字好得太多。在我们追求速度、准确、效率的过程中，纸笔的价值仍然不能被否定。 纸质的书籍厚重难找还不好修改，纯打字的笔记又没有手写的质感和灵感， iPad 搭配 Pencil 可以很好地结合电子产品和手写的优势，算是在其中找到了相对平衡的点。既能够保留⼿写的感官体验，⼜兼顾了电⼦笔记的轻便⾼效。 而除了硬件以外，适合自己的软件可以让笔记这件事事半功倍。 因此今天安利了这款软件：GoodNotes。 下面举个例子，来佐证下这款软件： 自由的书写体验对于 Notion 这样的非手写工具，有背后强大的 UI 做支撑，你每一个输入、每一次创建都不会破坏页面的严谨度和美感，似乎在使用的时候也会更加「郑重其事」，还有其独特的数据库功能。理性用户的选择， 但是相比之下 GoodNotes 则比较感性许多，手写的形式可以让人不必过分在意内容是否准确无误（GoodNotes 在 iPad 上拥有拥有完全媲美纸笔的流畅书写感受，尤其是在贴了类纸膜之后，书写体验更上一个台阶）。 GoodNotes 有四种笔可供选择。 钢笔有压感，但是压感变化不如画笔明显； 圆珠笔没有压感，无论多大力气写笔迹粗细都是一样的； 画笔也有压感，但笔迹粗细随下笔力度的变化更加明显。 荧光笔可以用来做标记，没有压感。 具体的笔迹效果如下图： （小 Tip: 插入 PDF 或 图片后，使用荧光笔时，它会自动置于文字下方。 ） 当然有了笔之后可是免不了一种就做橡皮擦的东西，毕竟不是每个人都能做到下过笔之后不作任何修改的。 优秀的文档管理方法做了笔记，接下来我们就要对它们进行收纳，保证之后能更方便地找到对应的内容。其中 GoodNotes 的文件管理逻辑与交互，和大家常用的电脑系统保持一致：拖拽实现移动、可随意切换视图和列表展示、文件夹支持层层嵌套…..，学习成本低，上手简单，文件情况一目了然。 文件夹管理 直接搜索如果没有进行收纳，GoodNotes 提供了一个简单的方法，就是「搜索」。 它能识别我们手写的文字——只要不是太潦草。 收藏重要的页面/笔记本笔记收藏在笔记页面，点击左上角的【收藏】按钮。 笔记本收藏在笔记本页面上，点击笔记本右上角的【⭐️】，即可。 制作目录有的时候，一个笔记本写多了，后期查找会比较困难。这时候，可以制作目录，快速定位。 （1）在某一页笔记上，点击右上角的【…】，然后选择【将此页面添加到大纲】。 （2）接下来，然后选择【大纲】，即可看到【索引】。点击其中某一个，可以快速到达对应的页面。 多平台同步GoodNotes 现在支持了源文件的迁移。比起只能保存为图片或者 PDF 的笔记工具，源文件的迁移让资料保存、共享都变得更简单了，结合 iCloud 的共享生态，再也不必担心后期的修改和整合，怎么变都能无缝衔接。 （在 ipad 上还可以设定其余的云存储。 分屏同时满足阅读和书写需求GoodNotes 可以支持同时显示两个笔记。以前一边用 PDF expert 看教材、PPT 或者试卷题型等，左边做标注，右边用 GoodNotes 记笔记。但这样做会导致左右两边的标注风格不一样，有的时候左右切换工具还反应不过来。但是现在同个 APP 可以支持同时显示两个笔记，分屏操作大大提高了统一性，文件管理也更方便了。 额外亮点操作制作模版虽然 GoodNotes 有提供非常多的模板，但是，根据自己的需要，有时候需要重新开发。这时候，我们可以制作属于自己的个性笔记本。 素材可以收藏你喜爱的图片、贴纸、文字等素材并随时取用。（表情包大户可用 有了素材可以制作漂亮的手账： 共享GoodNotes 目前还自带文件协作，共享笔墨的功能。 练字没错，这款软件还可提供练字功能。如下:","link":"/blogs/articles/2021/07/09/GoodNotes/"},{"title":"如何从Apple 美区官网购买礼品卡","text":"淘宝上怕有黑卡，那么我们现在可以通过美区官方的通道购买礼品卡，当然，你需要至少有个 双币信用卡 。按理应该 visa 卡都能用。大家可以试试看。 PS ：这个方法不是马上会收到，需要一点时间，官方写的是 4 小时以内，我大概不到 1 个小时就收到了。 Step_1 购买地址https://www.apple.com/shop/gift-cards/itunes-electronic Step_2 填写购买信息 Step_3 登陆 apple ID Step_4 填写支付信息美国地址生成器 Step_5 获取礼品兑换码 Step_6 在手机上输入兑换码打开Apple Store登录美区账号，点击头像。","link":"/blogs/articles/2021/04/02/apple-gift-card/"},{"title":"Chromium 历史版本离线安装包 - 下载方法","text":"Chrome(Chromium) 历史旧版本离线安装包下载方法。 Chrome 离线包 - 最新版（官方） 页面：https://www.google.com/intl/en/chrome/browser/desktop/index.html?standalone=1 点击Accept and Download会下载离线包（界面与在线安装类似，但确实是离线包） Chrome 离线包 - 历史版本（官方）下载：https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html 上述链接来自 Chromium 官网，含 Mac、Linux、Windows、Android、ChromiumOS 等 参考这里 https://chromium.googlesource.com/chromiumos/manifest-versions/+/master/paladin/buildspecs/ 来下载对应的离线版本包 参考这里https://vikyd.github.io/download-chromium-history-version/#/ 来下载对应的离线版本包","link":"/blogs/articles/2021/04/01/chrome-history-download/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/blogs/tags/hexo/"},{"name":"ci","slug":"ci","link":"/blogs/tags/ci/"},{"name":"download","slug":"download","link":"/blogs/tags/download/"},{"name":"chrome","slug":"chrome","link":"/blogs/tags/chrome/"},{"name":"chromium","slug":"chromium","link":"/blogs/tags/chromium/"},{"name":"history","slug":"history","link":"/blogs/tags/history/"},{"name":"js","slug":"js","link":"/blogs/tags/js/"},{"name":"export","slug":"export","link":"/blogs/tags/export/"},{"name":"export default","slug":"export-default","link":"/blogs/tags/export-default/"},{"name":"git","slug":"git","link":"/blogs/tags/git/"},{"name":"commit","slug":"commit","link":"/blogs/tags/commit/"},{"name":"lint","slug":"lint","link":"/blogs/tags/lint/"},{"name":"cli","slug":"cli","link":"/blogs/tags/cli/"},{"name":"github","slug":"github","link":"/blogs/tags/github/"},{"name":"proxy","slug":"proxy","link":"/blogs/tags/proxy/"},{"name":"vpn","slug":"vpn","link":"/blogs/tags/vpn/"},{"name":"empty","slug":"empty","link":"/blogs/tags/empty/"},{"name":"repository","slug":"repository","link":"/blogs/tags/repository/"},{"name":"configuration","slug":"configuration","link":"/blogs/tags/configuration/"},{"name":"questions","slug":"questions","link":"/blogs/tags/questions/"},{"name":"SEO","slug":"SEO","link":"/blogs/tags/SEO/"},{"name":"permalinks","slug":"permalinks","link":"/blogs/tags/permalinks/"},{"name":"md","slug":"md","link":"/blogs/tags/md/"},{"name":"hooks","slug":"hooks","link":"/blogs/tags/hooks/"},{"name":"husky","slug":"husky","link":"/blogs/tags/husky/"},{"name":"sourceTree","slug":"sourceTree","link":"/blogs/tags/sourceTree/"},{"name":"idea","slug":"idea","link":"/blogs/tags/idea/"},{"name":"prettier","slug":"prettier","link":"/blogs/tags/prettier/"},{"name":"tools","slug":"tools","link":"/blogs/tags/tools/"},{"name":"WebStorm","slug":"WebStorm","link":"/blogs/tags/WebStorm/"},{"name":"format","slug":"format","link":"/blogs/tags/format/"},{"name":"wx","slug":"wx","link":"/blogs/tags/wx/"},{"name":"install","slug":"install","link":"/blogs/tags/install/"},{"name":"rust","slug":"rust","link":"/blogs/tags/rust/"},{"name":"kill","slug":"kill","link":"/blogs/tags/kill/"},{"name":"lcasensor","slug":"lcasensor","link":"/blogs/tags/lcasensor/"},{"name":"dlp","slug":"dlp","link":"/blogs/tags/dlp/"},{"name":"koa","slug":"koa","link":"/blogs/tags/koa/"},{"name":"validator","slug":"validator","link":"/blogs/tags/validator/"},{"name":"JSON-Schema","slug":"JSON-Schema","link":"/blogs/tags/JSON-Schema/"},{"name":"lerna","slug":"lerna","link":"/blogs/tags/lerna/"},{"name":"monorepo","slug":"monorepo","link":"/blogs/tags/monorepo/"},{"name":"Mac","slug":"Mac","link":"/blogs/tags/Mac/"},{"name":"Apps","slug":"Apps","link":"/blogs/tags/Apps/"},{"name":"recommend","slug":"recommend","link":"/blogs/tags/recommend/"},{"name":"node","slug":"node","link":"/blogs/tags/node/"},{"name":"img","slug":"img","link":"/blogs/tags/img/"},{"name":"sharp","slug":"sharp","link":"/blogs/tags/sharp/"},{"name":"watermark","slug":"watermark","link":"/blogs/tags/watermark/"},{"name":"puppeteer","slug":"puppeteer","link":"/blogs/tags/puppeteer/"},{"name":"optimize","slug":"optimize","link":"/blogs/tags/optimize/"},{"name":"rgb","slug":"rgb","link":"/blogs/tags/rgb/"},{"name":"css","slug":"css","link":"/blogs/tags/css/"},{"name":"actions","slug":"actions","link":"/blogs/tags/actions/"},{"name":"workflow","slug":"workflow","link":"/blogs/tags/workflow/"},{"name":"terminal","slug":"terminal","link":"/blogs/tags/terminal/"},{"name":"upic","slug":"upic","link":"/blogs/tags/upic/"},{"name":"vs-code","slug":"vs-code","link":"/blogs/tags/vs-code/"},{"name":"plugins","slug":"plugins","link":"/blogs/tags/plugins/"},{"name":"ide","slug":"ide","link":"/blogs/tags/ide/"},{"name":"html","slug":"html","link":"/blogs/tags/html/"},{"name":"webpack","slug":"webpack","link":"/blogs/tags/webpack/"},{"name":"import","slug":"import","link":"/blogs/tags/import/"},{"name":"write","slug":"write","link":"/blogs/tags/write/"},{"name":"微信小程序","slug":"微信小程序","link":"/blogs/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"云开发","slug":"云开发","link":"/blogs/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"},{"name":"app","slug":"app","link":"/blogs/tags/app/"},{"name":"GoodNotes","slug":"GoodNotes","link":"/blogs/tags/GoodNotes/"},{"name":"apple","slug":"apple","link":"/blogs/tags/apple/"},{"name":"gift","slug":"gift","link":"/blogs/tags/gift/"},{"name":"card","slug":"card","link":"/blogs/tags/card/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/blogs/categories/hexo/"},{"name":"chrome","slug":"chrome","link":"/blogs/categories/chrome/"},{"name":"js","slug":"js","link":"/blogs/categories/js/"},{"name":"git","slug":"git","link":"/blogs/categories/git/"},{"name":"configuration","slug":"hexo/configuration","link":"/blogs/categories/hexo/configuration/"},{"name":"commit","slug":"git/commit","link":"/blogs/categories/git/commit/"},{"name":"idea","slug":"idea","link":"/blogs/categories/idea/"},{"name":"install","slug":"install","link":"/blogs/categories/install/"},{"name":"lcasensor","slug":"lcasensor","link":"/blogs/categories/lcasensor/"},{"name":"koa","slug":"koa","link":"/blogs/categories/koa/"},{"name":"lerna","slug":"lerna","link":"/blogs/categories/lerna/"},{"name":"Mac","slug":"Mac","link":"/blogs/categories/Mac/"},{"name":"sharp","slug":"sharp","link":"/blogs/categories/sharp/"},{"name":"puppeteer","slug":"puppeteer","link":"/blogs/categories/puppeteer/"},{"name":"css","slug":"css","link":"/blogs/categories/css/"},{"name":"github","slug":"github","link":"/blogs/categories/github/"},{"name":"vpn","slug":"vpn","link":"/blogs/categories/vpn/"},{"name":"upic","slug":"upic","link":"/blogs/categories/upic/"},{"name":"vs-code","slug":"vs-code","link":"/blogs/categories/vs-code/"},{"name":"rust","slug":"install/rust","link":"/blogs/categories/install/rust/"},{"name":"webpack","slug":"webpack","link":"/blogs/categories/webpack/"},{"name":"write","slug":"hexo/write","link":"/blogs/categories/hexo/write/"},{"name":"小程序","slug":"小程序","link":"/blogs/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"app","slug":"app","link":"/blogs/categories/app/"},{"name":"apple","slug":"apple","link":"/blogs/categories/apple/"},{"name":"validator","slug":"koa/validator","link":"/blogs/categories/koa/validator/"},{"name":"recommend","slug":"Mac/recommend","link":"/blogs/categories/Mac/recommend/"},{"name":"watermark","slug":"sharp/watermark","link":"/blogs/categories/sharp/watermark/"},{"name":"actions","slug":"github/actions","link":"/blogs/categories/github/actions/"},{"name":"github","slug":"upic/github","link":"/blogs/categories/upic/github/"},{"name":"plugins","slug":"vs-code/plugins","link":"/blogs/categories/vs-code/plugins/"},{"name":"rust","slug":"rust","link":"/blogs/categories/rust/"},{"name":"微信小程序","slug":"小程序/微信小程序","link":"/blogs/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"install","slug":"rust/install","link":"/blogs/categories/rust/install/"}]}