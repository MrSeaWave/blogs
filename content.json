{"pages":[{"title":"About me","text":".heimu { color: #000; background-color: #000; } .heimu:hover { color: #fff; } 95后前端开发一枚，爱好动漫，撸猫， 家有两只猫，一只蒂阿瑞（英短银渐层），一只逢坂大河（狸花猫），旅游，游戏，ps4（Fantasy_FishViy），switch党 独爱魂系游戏，欢迎一起来传火！ 2020年加入 如果青年 和朋友们一起搞事情，哇哈哈哈 博客主要写文章，技术 or 自己还没能解决的坑，但可能因为表述会有点问题，博客更多只是写给自己看的，如果发现不懂之处和可以改进的地方欢迎留言 🙏 本站文章如无特别声明，均为原创，转载请注明来源","link":"/blogs/about/index.html"},{"title":"友人帐","text":"function changeFrameHeight(){ const ifm= document.getElementById(\"blogFriend\"); ifm.height=ifm.contentWindow.document.body.scrollHeight; }; window.onresize=function(){ changeFrameHeight(); }","link":"/blogs/friends/index.html"},{"title":"留言板","text":"不留下点什么证明你来过吗~","link":"/blogs/messages/index.html"}],"posts":[{"title":"如何从Apple 美区官网购买礼品卡","text":"淘宝上怕有黑卡，那么我们现在可以通过美区官方的通道购买礼品卡，当然，你需要至少有个 双币信用卡 。按理应该 visa 卡都能用。大家可以试试看。 PS ：这个方法不是马上会收到，需要一点时间，官方写的是 4 小时以内，我大概不到 1 个小时就收到了。 Step_1 购买地址https://www.apple.com/shop/gift-cards/itunes-electronic Step_2 填写购买信息 Step_3 登陆 apple ID Step_4 填写支付信息美国地址生成器 Step_5 获取礼品兑换码 Step_6 在手机上输入兑换码打开Apple Store登录美区账号，点击头像。","link":"/blogs/articles/apple-gift-card/"},{"title":"Chromium 历史版本离线安装包 - 下载方法","text":"Chrome(Chromium) 历史旧版本离线安装包下载方法。 Chrome 离线包 - 最新版（官方） 页面：https://www.google.com/intl/en/chrome/browser/desktop/index.html?standalone=1 点击Accept and Download会下载离线包（界面与在线安装类似，但确实是离线包） Chrome 离线包 - 历史版本（官方）下载：https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html 上述链接来自 Chromium 官网，含 Mac、Linux、Windows、Android、ChromiumOS 等 参考这里 https://chromium.googlesource.com/chromiumos/manifest-versions/+/master/paladin/buildspecs/ 来下载对应的离线版本包 参考这里https://vikyd.github.io/download-chromium-history-version/#/ 来下载对应的离线版本包","link":"/blogs/articles/chrome-history-download/"},{"title":"修复 CI 构建博客造成的更新时间错误","text":"当使用 Travis CI or Github Actions 自动化部署时，发现部署成功后，所有文章的更新时间都变成了此次提交修改的时间，但有些文章在上一次提交后是没有发生过任何修改的。 这是因为 git 在推送更新时，并不记录保存文件的访问时间、修改时间等元信息，（原因在这里）所以每次使用 git 把项目 clone 下来时，文件的时间都是克隆时的时间。又因为如果没有在 front-matter 中指定 updated，Hexo 会默认使用文件的最后修改时间作为文章的更新时间，所以会出现所有文章的更新时间都发生变化的情况。 总的来说，使用 git clone 下来的文件的时间都不是原来文件的时间，而自动化部署每次都需要 clone 源码才能进行后面的生成和部署操作，所以目前如果想正确显示更新时间。需要： 方法一：使用 updated 属性字段在文章中的front-matter中添加updated: 更新时间项 front-matter12345title: 修复 CI 构建博客造成的更新时间错误author: Seatoc: truedate: 2021-01-07 15:53:16updated: 2021-01-07 15:53:16 以后修改文件的话也只需修改updated项对应日期即可，但是这样有个弊端，完全需要靠自己自觉去修改更新时间，自己一旦忘掉，那么更新时间的意义也就荡然无存了，因此这里推荐第二种方法。 方法二：使用 git 推送时间如果你用的是Travis Ci的话，只需要在.travis.yml添加如下配置： .travis.yml123before_install: # Restore last modified time - 'git ls-files -z | while read -d '''' path; do touch -d &quot;$(git log -1 --format=&quot;@%ct&quot; &quot;$path&quot;)&quot; &quot;$path&quot;; done' 如果你用的是Github Actions的话，只需要在对应的yml添加如下配置： actions123456jobs: &lt;jobs_id&gt;: steps: - name: Restore file modification time run: | &quot;git ls-files -z | while read -d '' path; do touch -d \\&quot;$(git log -1 --format=\\&quot;@%ct\\&quot; \\&quot;$path\\&quot;)\\&quot; \\&quot;$path\\&quot;; done&quot; 当然git ls-files 如果不好用可以改成 find： bash1find source/_posts -name '*.md' | while read file; do touch -d &quot;$(git log -1 --format=&quot;@%ct&quot; &quot;$file&quot;)&quot; &quot;$file&quot;; done 实际上，clone 下来的文件的时间还是克隆时的时间，然后通过上面的命令，它将 clone 下来的文件的时间改成了该文件最近一次变动的推送时间（也即文件最后一次修改的 push 时间）。 注：如果github actions中使用actions/checkout@v2，请设定它的参数fetch-depth: 0，因为0表示获取所有分支和标签的所有历史记录。默认值为1 小知识： bash12345678# 获取 git 仓库中所有文件的最新修改时间git ls-tree -r --name-only HEAD | while read filename; do echo &quot;$(git log -1 --format=&quot;%ad&quot; -- $filename) $filename&quot;done# 获取 git 仓库中所有文件的最初创建时间git ls-tree -r --name-only HEAD | while read filename; do echo &quot;$(git log --format=&quot;%ad&quot; -- $filename | tail -1) $filename&quot;done 参考链接 GIT 获取文件最初创建及最新修改日期 How to retrieve the last modification date of all files in a git repository：介绍了如何获取 git 仓库中，所有文件的最新修改时间。 Finding the date/time a file was first added to a Git repository：介绍了如何获取 git 仓库中，所有文件最初的创建时间。 Hexo 相关问题和优化 The update time of the article is incorrect 修复 CI 构建博客造成的更新时间错误","link":"/blogs/articles/ci-hexo-update-time/"},{"title":"谷歌浏览器历史版本下载","text":"本文将介绍谷歌浏览器历史版本如何下载及其代码仓库原理介绍。 打开网页 https://mrseawave.github.io/chromium-history-page/ ，选择对应的 OS，与 version 点击进行下载即可。 网页源码：https://github.com/MrSeaWave/chromium-history-page dataSource：https://github.com/MrSeaWave/chromium-history-dataSource crawler(BASE): https://github.com/MrSeaWave/chromium-history-crawler 原理介绍crawler 仓库代码解析 Step_1寻找所有的 version&amp;&amp;version 对应的 position getPositionByVersion1$ node ./src/getPositionByVersion.js versionUrl + versionPositionUrl====&gt;生成 all-version.json, version-position.json versionUrl ：爬虫获取所有 version versionPositionUrl: 通过指定的 version 获取特定的 position all-version.json: all-version.json1234567[ &quot;90.0.4399.1&quot;, &quot;90.0.4399.0&quot;, &quot;90.0.4398.1&quot;, &quot;90.0.4398.0&quot; // ...] version-position.json: version-position.json1234567{ &quot;90.0.4399.1&quot;: &quot;846615&quot;, &quot;90.0.4399.0&quot;: &quot;846615&quot;, &quot;90.0.4398.1&quot;: &quot;846545&quot;, &quot;90.0.4398.0&quot;: &quot;846545&quot; // ...} Step_2寻找不同 os 对应的 position：position/position-Mac.json etc. getPositionWithOsList1$ node ./src/getPositionWithOsList.js positionUrl====&gt;position/position-Mac.json position-Mac.json: position-Mac.json1234567[ &quot;15734&quot;, &quot;15749&quot;, &quot;15839&quot;, &quot;15942&quot; // ...] Step_3结合step_1与step_2的数据生成最终文件：ver-pos-os/version-position-Mac.json verPosOsGen.js1$ node ./src/verPosOsGen version-position.json &amp;&amp; position/position-os.json ===&gt; ver-pos-os/version-position-Mac.json etc. ver-pos-os.json: ver-pos-os.json1234567{ &quot;90.0.4398.1&quot;: &quot;846545&quot;, &quot;90.0.4398.0&quot;: &quot;846545&quot;, &quot;90.0.4396.2&quot;: &quot;845872&quot;, &quot;90.0.4396.1&quot;: &quot;845872&quot; // ...} json stepsjson-steps123all-version.json -&gt; version-position.json -&gt; -&gt; ver-pos-[os].json position-[os].json -&gt; Step_4 数据存储：将上述steps中生成的json文件夹下的数据复制到chromium-history-dataSource仓库中，留作备份。 网页发布：将ver-pos-os/version-position-Mac.json复制到前端代码仓库:chromium-history-page public文件夹下，并且发布前端代码至chromium-history-page的gh-pages分支上 至此打开网页即可看到谷歌浏览器的历史版本。🚀🚀🚀 参考链接 仓库代码参考：chromium-history-version-crawler","link":"/blogs/articles/download-chromium-history-version/"},{"title":"export 与 export default 的区别","text":"本文将介绍 export 与 export default 的差异性。 1. export default 在一个模块里只能有一个，但是 export 可以有多个123456789// model.jslet e1 = 'export 1';let e2 = 'export 2';let e3 = 'export 3';let e4 = 'export 4';export { e2 };export { e3 };export { e4 };export default e1; 1234567// 使用模块的run.jsimport e1, { e2, e3, e4 } from './model.js';console.log(e1);console.log(e2);console.log(e3);console.log(e4); 1234567run.js运行结果$ node run.jsexport 1export 2export 3export 4 如果在model.js再添加一个export default 12let e5 = 'export e5';export default e5; 123456$ node run.jsfile:///Users/xxx/workspace/model.js:11export default e5 ^^^^^^^^^^^SyntaxError: Identifier '.default' has already been declared 2. 模块中通过export 导出的(属性或者方法)可以修改，但是通过export default导出的不可以修改基本类型： 123456789// model.jslet e1 = 'export 1';let e2 = 'export 2';export function modifyFunc() { e1 = 'export 1 modified'; e2 = 'export 2 modified';}export { e2 };export default e1; 1234567// 使用模块的run.jsimport e1, { e2, modifyFunc } from './model.js';console.log(e1);console.log(e2);modifyFunc();console.log(e1);console.log(e2); 12345$ node run.jsexport 1export 2export 1export 2 modified Babel 编译后代码 123456789101112131415161718'use strict';Object.defineProperty(exports, '__esModule', { value: true,});exports.modifyFunc = modifyFunc;exports.default = exports.e2 = void 0;let e1 = 'export 1';let e2 = 'export 2';exports.e2 = e2;function modifyFunc() { e1 = 'export 1 modified'; exports.e2 = e2 = 'export 2 modified';}var _default = e1;exports.default = _default; 对象 123456789let e1 = { v1: 'v1' };let e2 = { v2: 'v2' };export function modifyFunc() { e1 = { v1: 'v1 modified' }; e1.v1 = 'v1 next modified'; e2 = { v22: 'v2 modified' };}export { e2 };export default e1; 1234567// 使用模块的run.jsimport e1, { e2, modifyFunc } from './model.js';console.log(e1);console.log(e2);modifyFunc();console.log(e1);console.log(e2); 12345$ node run.js{ v1: 'v1' }{ v2: 'v2' }{ v1: 'v1' }{ v22: 'v2 modified' } Babel 编译后代码 12345678910111213141516171819202122232425262728'use strict';Object.defineProperty(exports, '__esModule', { value: true,});exports.modifyFunc = modifyFunc;exports.default = exports.e2 = void 0;// model.jslet e1 = { v1: 'v1',};let e2 = { v2: 'v2',};exports.e2 = e2;function modifyFunc() { e1 = { v1: 'v1 modified', }; e1.v1 = 'v1 next modified'; exports.e2 = e2 = { v22: 'v2 modified', };}var _default = e1;exports.default = _default; 首先需要了解到： ES6 中模块通过export和export default暴露出来的属性或者方式并不是普通的赋值或者引用，它们是对模块内部定义的标志符类似指针的绑定。 对于一个导出的属性或者方法，在什么地方导出不重要，在什么时候导入也不重要，重要的是:访问这这个绑定的时候的当前值。 123456789// model.jslet e1 = 'export 1';let e2 = 'export 2';export { e2 };export default e1;e1 = 'export 1 modified';setTimeout(() =&gt; { e2 = 'export 2 modified';}, 1000); 1234567// 使用模块的run.jsimport e1, { e2 } from './model.js';console.log(e1);console.log(e2);setTimeout(() =&gt; { console.log('-----later-----', e2);}, 5000); 1234$ node run.jsexport 1export 2-----later----- export 2 modified Babel 编译后代码 12345678910111213141516'use strict';Object.defineProperty(exports, '__esModule', { value: true,});exports.default = exports.e2 = void 0;// model.jslet e1 = 'export 1';let e2 = 'export 2';exports.e2 = e2;var _default = e1;exports.default = _default;e1 = 'export 1 modified';setTimeout(() =&gt; { exports.e2 = e2 = 'export 2 modified';}, 1000); 但是，export是绑定到标识符，改变标志符的值，然后访问这个绑定，得到的是新值；export default绑定的是标志符指向的值，如果修改标志符指向另一个值，这个绑定的值不会发生变化。 如果想修改默认导出的值，可以使用export {e1 as default}这种方法。 1234// model.jslet e1 = 'export 1';export { e1 as default };e1 = 'export 1 modified'; 123// 使用模块的run.jsimport e1 from './model.js';console.log(e1); 123$ node run.jsexport 1 modified Babel 编译后代码 12345678910'use strict';Object.defineProperty(exports, '__esModule', { value: true,});exports.default = void 0;// model.jslet e1 = 'export 1';exports.default = e1;exports.default = e1 = 'export 1 modified'; 3. export default与export语法差异。 export var e1='...' 是合法语句，但是export default var e2='...'是不合法的（let和const也一样）。 export default可以直接添加标识符导出，例如export default e2;export如果要导出已经声明的表示符,必须使用{},例如export {e1},注意：这里{}不是声明一个对象。 可查看例子源码","link":"/blogs/articles/export-export-default/"},{"title":"工程化配置 git commit 规范","text":"如果你团队的 git commit 信息紊乱，太过糟糕，觉得有必要统一规范 commit格式，又或者你是一个强迫症患者，有必要让 commit 信息整整齐齐的展示。那么，你可以往下瞅瞅。 本文使用的插件版本 pkg123456{ &quot;@commitlint/cli&quot;: &quot;^12.0.1&quot;, &quot;@commitlint/config-conventional&quot;: &quot;^12.0.1&quot;, &quot;husky&quot;: &quot;4.3.8&quot;, &quot;standard-version&quot;: &quot;^9.1.1&quot;} git commit 规范格式现在比较大众化的 commit 格式无非有两种： git12$ &lt;commit-type&gt;[(commit-scope)]: &lt;commit-message&gt;$ &lt;commit-icon&gt;: &lt;commit-message&gt; &lt;commit-type&gt; 常见为： chore：构建配置相关。 docs：文档相关。 feat：添加新功能。 fix：修复 bug。 pref：性能相关。 refactor：代码重构，一般如果不是其他类型的 commit，都可以归为重构。 revert：分支回溯。 style：样式相关。 test：测试相关。 [(commit-scope)] 可选，表示范围，例如：refactor(cli)，表示关于 cli 部分的代码重构。 &lt;commit-message&gt; 提交记录的信息，有些规范可能会要求首字母大写。 &lt;commit-icon&gt; 用图标来替代 &lt;commit-type&gt; 所表示的功能。 具体规范信息格式在这里查看（这里不做过多阐述） 用于 commit 规范的工具 commitizen commitlint gitmoji 本文主要讲述第二种(commitlint)使用方法，如想使用更多请查看demo commitlint 使用yarn1$ yarn add @commitlint/config-conventional @commitlint/cli --D 在专门的 commitlint 配置文件 commitlint.config.js 中配置如下： commitlint.config.js123module.exports = { extends: ['@commitlint/config-conventional'],}; 类似于 eslint，commitlint 还支持类似于 .commitlintrc.js、.commitlintrc.json、.commitlintrc.yml 名称的配置文件，又或者在 package.json 中添加 commitlint 字段。 然后安装 husky，这是为了添加 git hooks，使得 git commit 也能够符合 commit 规范。 yarn1$ yarn add husky --dev 在 package.json 中配置 husky 钩子： (v1.0.1版本以后为HUSKY_GIT_PARAMS，v0.14.3为GIT_PARAMS) package.json1234567{ &quot;husky&quot;: { &quot;hooks&quot;: { &quot;commit-msg&quot;: &quot;commitlint -e $HUSKY_GIT_PARAMS&quot; } }} 上面的操作如果都成功的话，那么你使用 git commit 命令时，就必须老老实实的使用符合 commitlint 规范的信息了 standard-version 使用yarn1$ yarn add standard-version -D standard-version是帮助项目自动生成ChangeLog、升版本、打tag的工具，它基于semver和Conventional Commits规范。（PS：配合git commit规范化食用更加。 当执行server-version命令后，它会自动完成以下操作： 取得当前版本（比如package.json里面的version字段），升版本：1.0.0 =&gt; 1.1.0 或者 1.0.0 =&gt; 2.0.0等（如何升级可以由参数控制） 基于commits生成ChangeLog文件 提交一个commit，包含ChangeLog和版本变更的文件 打tag 以上功能都是可配置跳过的，对应：bump、changelog、commit、tag。比如在配置文件中按照如下配置，就可以跳过打tag操作： 12345{ &quot;skip&quot;: { &quot;tag&quot;: true }} 为standard-version添加配置有两种方式： 目前使用的配置文件如下，其它配置参考官方文档： .versionrc.js1234567891011121314151617181920212223242526272829303132333435363738394041424344// https://github.com/conventional-changelog/conventional-changelog-config-spec/blob/master/versions/2.1.0/README.mdmodule.exports = { // 跳过一些操作 bump、changelog、commit、tag skip: { // 不跳过打tag操作 tag: false, }, //types为Conventional Commits标准中定义，目前支持 //https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional types: [ { type: 'feat', section: '新特性' }, { type: 'fix', section: 'Bug修复' }, { type: 'docs', section: '文档' }, { type: 'chore', section: '配置项', hidden: true }, { type: 'style', section: '格式', hidden: true }, { type: 'refactor', section: '重构', hidden: true }, { type: 'perf', section: '性能', hidden: true }, { type: 'test', section: '测试', hidden: true }, { type: 'build', section: '构建', hidden: true }, { type: 'ci', section: 'CI', hidden: true }, { type: 'revert', section: '回滚', hidden: true }, ], //compare 链接 推荐自行修改为仓库地址 如 compareUrlFormat: '{{host}}/{{owner}}/{{repository}}/compare/{{previousTag}}...{{currentTag}}', //hash链接 推荐自行修改为仓库地址 如 https://github.com/MrSeaWave/commit-standard-demo/commit/{{hash}} commitUrlFormat: '{{host}}/{{owner}}/{{repository}}/commit/{{hash}}', //issue链接 issueUrlFormat: '{{host}}/{{owner}}/{{repository}}/issues/{{id}}', //server-version自动commit的模板 releaseCommitMessageFormat: 'build: v{{currentTag}}版本发布', //需要server-version更新版本号的文件 bumpFiles: [ { filename: 'MY_VERSION_TRACKER.txt', // The `plain-text` updater assumes the file contents represents the version. type: 'plain-text', }, { filename: 'package.json', // The `json` updater assumes the version is available under a `version` key in the provided JSON document. type: 'json', }, ],}; package.json 配置: package.json12345678&quot;scripts&quot;: { ..., &quot;release&quot;: &quot;standard-version&quot;, &quot;release:major&quot;: &quot;standard-version --release-as major&quot;, &quot;release:minor&quot;: &quot;standard-version --release-as minor&quot;, &quot;release:patch&quot;: &quot;standard-version --release-as patch&quot;, &quot;release:prerelease&quot;: &quot;standard-version --prerelease&quot; } PS: standard-version 有很多其他的特性，这里不过多涉及， 有兴趣的可以自行尝试。也可以查看此demo 参考链接 Git 的学与记：工程化配置 commit 规范 代码风格自动化","link":"/blogs/articles/git-commit-cli/"},{"title":"Git提交信息规范","text":"Git 每次提交代码，都要写 Commit message（提交说明） 1$ git commit -m &quot;hello world&quot; 上面代码的-m 参数，就是用来指定 commit mesage 的。 如果一行不够，可以只执行git commit，就会跳出文本编辑器，让你写多行. 1$ git commit Commit message 的格式每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。 12345&lt;Header&gt;&lt;Body&gt;&lt;Footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。 HeaderHeader 部分只有一行，包括三个字段：type（必需）、scope（可选）、subject（必需）。 1&lt;type&gt;: &lt;subject&gt; typetype 用于说明 commit 的类别，只允许使用下面 7 个标识。 feat：新功能（feature） fix：修补 bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 subjectsubject 是 commit 目的的简短描述，不超过 50 个字符。 以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes 第一个字母小写 结尾不加句号（.） BodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 1234567More detailed explanatory text, if necessary. Wrap it toabout 72 characters or so.Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent 有两个注意点。 使用第一人称现在时，比如使用 change 而不是 changed 或 changes。 应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用于两种情况： 关联 Issue 关闭 Issue 关联 Issue本次提交如果和摸个 issue 有关系则需要写上这个，格式如下： 1Issue #1, #2, #3 关闭 Issue如果当前提交信息解决了某个 issue，那么可以在 Footer 部分关闭这个 issue，关闭的格式如下： 1Close #1, #2, #3 Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 1234revert: feat(pencil): add 'graphiteWidth' optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body 部分的格式是固定的，必须写成 This reverts commit &amp;lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 例子12345678910feat: 添加了分享功能给每篇博文添加了分享功能- 添加分享到微博功能- 添加分享到微信功能- 添加分享到朋友圈功能Issue #1, #2Close #1 使用软件进行 commit 规范化 JS: commit-demo 参考文档 Commit message 和 Change log 编写指南 我的提交信息规范","link":"/blogs/articles/git-commit-message/"},{"title":"git仓库的代理","text":"因为种种原因，github访问很困难，仓库代码的提交比较受限，因此想到通过挂代理的方式让代码可以正常提交。 首先第一步，肯定需要shdowsocks代理工具。 其次 全局设定： http1$ git config --global http.proxy http://127.0.0.1:1087 https1$ $ git config --global https.proxy https://127.0.0.1:1087 or 只针对特定仓库设定： http1$ git config http.proxy http://127.0.0.1:1087 https1$ git config https.proxy https://127.0.0.1:1087 注：127.0.0.1:1087是因为","link":"/blogs/articles/git-proxy/"},{"title":"git-repository","text":"本文讲述如何上传本地代码到远程的空仓库。 Create a new repository123456git clone https://github.com/MrSeaWave/tem.gitcd temtouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin master Push an existing folder123456cd existing_foldergit initgit remote add origin https://github.com/MrSeaWave/tem.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master Push an existing Git repository12345cd existing_repogit remote rename origin old-origingit remote add origin https://github.com/MrSeaWave/tem.gitgit push -u origin --allgit push -u origin --tags","link":"/blogs/articles/git-repository/"},{"title":"hexo 相关问题以及优化配置","text":"前言本文记录一些 hexo 出现的问题及其解决方案，以及相关配置 hexo 环境 env1234hexo: 5.3.0hexo-cli: 4.2.0os: Darwin 19.6.0 darwin x64node: 15.2.1 禁止爬虫跟踪外链搜索引擎的蜘蛛来爬取文章内容时，如果你的文章中有外部链接，它就会到外链的站点去爬取，有可能再也不会回来了。为了告诉搜索引擎不要跟踪这些外链，需要在这些链接标签中添加属性 rel=&quot;nofollow&quot; 或 rel=&quot;external nofollow&quot; 。 rel=&quot;nofollow&quot; 是通用格式，即是告诉搜索引擎不要跟踪此链接，rel=&quot;external nofollow&quot; 是更具体的写法，进一步告诉搜索引擎这是一个外部的链接，不要跟踪它。 我们可以使用 hexo-filter-nofollow 自动为 Hexo 博客中的外链添加 rel=&quot;external nofollow noreferrer&quot;的插件，从而改善你的网站的安全性和 SEO。 安装install1$ npm i hexo-filter-nofollow --save 编辑 _config.yml在 站点配置文件 _config.yml 末尾添加如下内容： _config.yml123456nofollow: enable: true field: site exclude: - &quot;exclude1.com&quot; - &quot;exclude2.com&quot; enable - 是否启用插件，默认值为 true field - 插件的处理范围，默认值为 site，可选 post 或 site post - 仅处理文章内容 site - 处理全站所有页面 exclude - 域名白名单，不同的子域名视为不同的域名（如 www） exclude1.com不包括 www.exclude1.com 或 en.exclude1.com 永久链接因链接层级过深、链接中包含中文、 title 变动导致链接也经常发生变动，这些都不利于 SEO 。 方法一：按照文件名称生成假设文章： md123456# source/_posts/lorem/hello-world.mdtitle: Hello World Pagedate: 2013-07-14 17:01:34categories: - foo - bar 根据官网介绍在_config.yml中设定： _config.yml123456# title: 文件名称 (relative to “source/_posts/“ folder)permalink: :title/# url:-----&gt; /lorem/hello-world/# name: 文件名称permalink: :name/# url:-----&gt; /hello-world/ 问题来了，如果按照文件名称生成永久链接的，我的文件格式都要是这类 英文字母.md 的格式。如果是中文中文.md那么就会变成/中文/，浏览器地址栏上很不美观，对 SEO 也不好。 有没有办法让 Markdown 文件用 你好世界.md 这类中文文件名保存，生成的永久链接格式又是 /hello-world/ 这种样式呢？ Markdown Front-matter 区域可以看到，我这里除了 title， date 以及 tags 外，自己添加了一个新的变量 customUrl ，这个新的变量用来保存每个文章的英文名字，这样一来可以有利于 SEO，二来可以缩短博客文章 URL 的层数。 front-matter123title: Hello World Page# 自定义的变量customUrl: custom-hello-world 再在 hexo 配置文件 _config.yml 中，把 permalink: 的值设为 :customUrl/ 。 _config.yml12permalink: :customUrl/# url:------&gt; /custom-hello-world/ 方法二：使用 hexo-abbrlink推荐使用插件 hexo-abbrlink 生成 permalink 。 安装install1$ npm install hexo-abbrlink --save 使用然后在配置文件_config.yml 中修改： _config.yml12345permalink: :abbrlink/#abbrlink配置abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 执行 hexo clean &amp;&amp; hexo g 重新生成静态文件后，源文件 front-matter 中会包含 abbrlink: xxx 。 如果文章中未指定 abbrlink: xxx，将会根据算法随机生成数字 这样就确保了链接的唯一化，只要不修改 md 文件的 abbrlink 的值，url 就永久不会改变。 使用这种方法生成 permalink 时，在每次提交修改前，最好先执行 hexo clean &amp;&amp; hexo g，确保提交前你所有的文章的 front-matter 中都包含 abbrlink ，避免因 title 的改变导致生成 abbrlink 不一致（如果已存在 abbrlink，就不会重新生成，不论title 是否发生变化）。 参考链接 Hexo 相关问题和优化 hexo-filter-nofollow - Hexo 官方的 nofollow 插件 Hexo 永久链接管理 永久链接（Permalinks） hexo-abbrlink","link":"/blogs/articles/hexo-configuration/"},{"title":"Husky hooks skipped","text":"在sourceTree遇到使用husky 会报错的情况： error123....Can't find yarn in PATH:......Skipping pre-push hook 解决方案： add this in ~/.huskyrc: huskyrc1PATH=&quot;/usr/local/bin:$PATH&quot; 参考链接 Husky hooks skipped Commit hooks are skipped due to PATH issues","link":"/blogs/articles/husky-error-gui/"},{"title":"Prettier: support &quot;overrides&quot; option on code styles import","text":"在直接调用 WebStorm 自带的 Prettier 去格式化 wxml / wxss / wxs 文件会提示： File xxx has unsupported type 猜想 Prettier 应该提供任意文件映射为任意已支持的文件类型的格式化配置。查阅官方文档后：Setting the parser option，于是有了下面配置。 prettierrc123456789101112131415161718192021222324{ &quot;prettier&quot;: { &quot;overrides&quot;: [ { &quot;files&quot;: &quot;*.wxml&quot;, &quot;options&quot;: { &quot;parser&quot;: &quot;html&quot; } }, { &quot;files&quot;: &quot;*.wxss&quot;, &quot;options&quot;: { &quot;parser&quot;: &quot;css&quot; } }, { &quot;files&quot;: &quot;*.wxs&quot;, &quot;options&quot;: { &quot;parser&quot;: &quot;babel&quot; } } ] }} 于是在某个小程序文件中再次尝试调用 WebStorm 自带的 Prettier，发现依然是那个错误提示，重启也无果。。但是 vscode 却可以正常使用了。 又试了下手动在命令行里敲： 1npx prettier xx --write 成功，于是判断问题出在 webstorm 上。 尝试修复： 全局安装 Prettier，这样方便跨项目复用（可选 Preferences - Tools - External Tools 点击当前窗口左下角 + 号 Name、Description 自己起一个吧 Program 里填写：Prettier 安装位置/bin-prettier.js Arguments 里填写：$FilePath$ --write Working directory 不用管，ok、apply 双连保存配置 以上步骤完成之后你就可以通过顶部菜单：Tools - External Tools - 你起的 Tool Name 来格式化当前的小程序文件了。再说说快捷键的配置步骤： Preferences - Keymap 当前窗口右上角搜索你创建的 Tool Name 在搜索结果里选中它 Add Keyboard Shortcut 吧！ 参考链接 WebStorm 微信小程序代码提示 + Prettier 代码格式化 Prettier: support “overrides” option on code styles import","link":"/blogs/articles/idea-prettier/"},{"title":"rust 安装","text":"Rust 通常被称为 rust-lang。Rust 是一个由 Mozilla Research 赞助的通用的、多范式、现代的、跨平台和开源系统编程语言。 它旨在实现安全性、速度和并发性等目标。 Rust 在语法上与 C++ 相似，但它的设计者希望它在保持性能的同时提供更好的内存安全性。 Rust 目前在许多组织中使用，例如 Firefox、Chef、Dropbox、Oracle、GNOME 等。 如何在 Mac 中安装 Rust 语言？我们可以通过多种方式安装 Rust，但以下是官方推荐的安装方式。 install12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | shinfo: downloading installerWelcome to Rust!This will download and install the official compiler for the Rustprogramming language, and its package manager, Cargo.Rustup metadata and toolchains will be installed into the Rustuphome directory, located at: /Users/xmly/.rustupThis can be modified with the RUSTUP_HOME environment variable.The Cargo home directory located at: /Users/xmly/.cargoThis can be modified with the CARGO_HOME environment variable.The cargo, rustc, rustup and other commands will be added toCargo's bin directory, located at: /Users/xmly/.cargo/binThis path will then be added to your PATH environment variable bymodifying the profile files located at: /Users/xmly/.profile /Users/xmly/.zshenvYou can uninstall at any time with rustup self uninstall andthese changes will be reverted.Current installation options: default host triple: x86_64-apple-darwin default toolchain: stable (default) profile: default modify PATH variable: yes1) Proceed with installation (default)2) Customize installation3) Cancel installation&gt;info: profile set to 'default'info: default host triple is x86_64-apple-darwininfo: syncing channel updates for 'stable-x86_64-apple-darwin'info: latest update on 2020-12-31, rust version 1.49.0 (e1884a8e3 2020-12-29)info: downloading component 'cargo' 4.1 MiB / 4.1 MiB (100 %) 3.3 MiB/s in 1s ETA: 0sinfo: downloading component 'clippy'info: downloading component 'rust-docs' 13.8 MiB / 13.8 MiB (100 %) 2.3 MiB/s in 6s ETA: 0sinfo: downloading component 'rust-std' 21.1 MiB / 21.1 MiB (100 %) 2.3 MiB/s in 9s ETA: 0sinfo: downloading component 'rustc' 50.8 MiB / 50.8 MiB (100 %) 2.3 MiB/s in 22s ETA: 0sinfo: downloading component 'rustfmt'info: installing component 'cargo'info: using up to 500.0 MiB of RAM to unpack componentsinfo: installing component 'clippy'info: installing component 'rust-docs' 13.8 MiB / 13.8 MiB (100 %) 3.4 MiB/s in 4s ETA: 0sinfo: installing component 'rust-std' 21.1 MiB / 21.1 MiB (100 %) 3.6 MiB/s in 5s ETA: 0sinfo: installing component 'rustc' 50.8 MiB / 50.8 MiB (100 %) 7.4 MiB/s in 7s ETA: 0sinfo: installing component 'rustfmt'info: default toolchain set to 'stable-x86_64-apple-darwin' stable-x86_64-apple-darwin installed - rustc 1.49.0 (e1884a8e3 2020-12-29)Rust is installed now. Great!To get started you need Cargo's bin directory ($HOME/.cargo/bin) in your PATHenvironment variable. Next time you log in this will be doneautomatically.To configure your current shell, run:source $HOME/.cargo/env 运行以下命令配置当前 shell。 source1$ source $HOME/.cargo/env 运行以下命令验证已安装的 Rust 版本。 rust version12$ rustc --versionrustc 1.49.0 (e1884a8e3 2020-12-29) 如何测试 Rust 编程语言安装 Rust 后，请按照以下步骤检查 Rust 语言是否正常工作。 创建一个文件并添加以下代码并保存。确保 Rust 文件始终以 .rs 扩展名结尾。 index1234$ vim index.rsfn main() { println!(&quot;Hello World&quot;);} 运行以下命令编译 rust 代码。 rust1$ rustc index.rs 上面的命令将在同一目录中创建一个可执行的 Rust 程序。 ls1234$ ls -lhtotal 760-rwxr-xr-x 1 xmly staff 375K 1 20 10:45 index-rw-r--r-- 1 xmly staff 41B 1 20 10:36 index.rs 运行 Rust 可执行文件得到输出。 run12$ ./indexHello World 好了！正常工作了。 参考链接 Rustup for managing Rust versions rust","link":"/blogs/articles/install-rust/"},{"title":"如何杀死lcasensor进程","text":"本文讲述如何杀死 lcasensor（内网的监控软件，敏感数据监控）这个进程。 一下操作均是在 MacOs 环境下运行。 1. 定位进程信息1$ ps aux |grep didi 找到 4 个相似进程： /opt/didi/lca/bin/lcasensor /opt/didi/lca/bin/lcaupdater /opt/didi/lca/bin/LCAService /opt/didi/lca/bin/lcaagent 2. 检查自动启动目录 /Library/LaunchDaemons /Library/LaunchAgents ~/Library/LaunchAgents /System/Library/LaunchDaemons /System/Library/LaunchAgents 找到 4 份配置文件： /Library/LaunchAgents/com.didi.lca.lcaagent.plist /Library/LaunchDaemons/com.didi.lca.lcasensor.plist /Library/LaunchDaemons/com.didi.lca.lcaservice.plist /Library/LaunchDaemons/com.didi.lca.lcaupdater.plist 3. 修改自动启动选项分别修改com.didi.lca.*.plist的内容，主要改下面 2 个地方。 请确认修改以后的效果是：KeepAlive=false，RunAtLoad=false com.didi.lca.*.plist1234&lt;key&gt;KeepAlive&lt;/key&gt;&lt;false/&gt;&lt;key&gt;RunAtLoad&lt;/key&gt;&lt;false/&gt; 4. 重新启动电脑验证检查一下进程信息，确认进程已经停止运行 1$ ps aux |grep didi 删除上述提到的相关文件即可避免再次运行 1234$ sudo rm -rf /Library/LaunchAgents/com.didi.lca.*.plist$ sudo rm -rf /Library/LaunchDaemons/com.didi.lca.*.plist$ sudo rm -rf /opt/didi/lca$ sudo rmdir /opt/didi End! 🎉🎉🎉 参考链接 知乎","link":"/blogs/articles/kill-lcasensor/"},{"title":"lerna","text":"lerna-demoLerna 是一个工具，它优化了使用 git 和 npm 管理多包存储库的工作流。 本文通过一个示例讲述了如何基于 Lerna 管理多个 package，并和其它工具整合，打造高效、完美的工作流，最终形成一个最佳实践。 工作的两种模式Fixed/Locked mode (default)vue,babel 都是用这种，在 publish 的时候,会在 lerna.json 文件里面&quot;version&quot;: &quot;0.1.0&quot;依据这个号，进行增加，只选择一次，其他有改动的包自动更新版本号。 Independent modelerna init --independent 初始化项目。 lerna.json 文件里面&quot;version&quot;: &quot;independent&quot;, 每次 publish 时，您都将得到一个提示符，提示每个已更改的包，以指定是补丁、次要更改、主要更改还是自定义更改。 项目构建init12$ mkdir lerna-demo &amp;&amp; cd $_$ npx lerna init 生成以下文件 1234lerna-demo/ packages/ package.json lerna.json 增加 packages创新一些新的 pkg 123456789101112$ cd packages$ mkdir pkg-a pkg-b pkg-c$ cd pkg-a$ npm init --y$ cd pkg-b$ npm init --y或者使用$ lerna create pkg-d --y 项目结构如下 123456789101112131415161718192021$ tree.├── README.md├── lerna.json├── package.json└── packages ├── pkg-a │ └── package.json ├── pkg-b │ └── package.json ├── pkg-c │ └── package.json └── pkg-d ├── README.md ├── __tests__ │ └── pkg-d.test.js ├── lib │ └── pkg-d.js └── package.json7 directories, 10 files 依赖管理 yarn是lerna的最佳搭档。 lerna默认使用npm作为安装依赖包工具，但也可以选择其他工具。把 npm 替换成 yarn 只需在 lerna 的配置文件添加两行代码即可，配置完以后立刻顺畅百倍。 1234567// lerna.json{ &quot;packages&quot;: [&quot;packages/*&quot;], // 配置package目录 &quot;version&quot;: &quot;independent&quot;, &quot;npmClient&quot;: &quot;yarn&quot;, &quot;useWorkspaces&quot;: true // 使用yarn workspaces} 配置 package.json 使用yarn workspaces 1234567891011{ &quot;name&quot;: &quot;root&quot;, &quot;private&quot;: true, // root禁止发布 &quot;devDependencies&quot;: { &quot;lerna&quot;: &quot;^4.0.0&quot; }, &quot;workspaces&quot;: [ // 配置package目录 &quot;packages/*&quot; ]} 安装依赖只要在项目主目录下执行 1$ yarn install yarn 会自动读取 workspace 配置，就能自动安装、处理、软链接各个子包的依赖，统一放在根目录下。也可以使用 lerna 的安装命令 1$ lerna bootstrap 但可能不如 yarn 的包管理机制好用，可以看这篇文章《Lerna 的依赖管理及 hoisting 浅析》 增删依赖123$ lerna add chalk # 为所有 package 增加 chalk 模块$ lerna add semver --scope pkg-a # 为 pkg-a 增加 semver 模块$ lerna add pkg-a --scope pkg-b # 增加内部模块之间的依赖 or 123$ yarn workspaces run add chalk # 为所有 package 增加 chalk 模块$ yarn workspace pkg-a add semver # 为 pkg-a 增加 semver 模块$ yarn workspace pkg-b add pkg-a@1.0.0 # 这里必须加上版本号，否则报错,将pkg-a作为pkg-b的依赖 更多请查看lerna add 对应的 yarn 的更多命令： 主项目添加依赖 1$ yarn add [packageName] -W -D -W 是指定在项目根目录执行命令 删除公共依赖 1$ yarn remove -W -D [packageName] 给所有子项目增删依赖 12$ yarn workspaces run add [packageName]$ yarn workspaces run remove [packageName] 给某个项目增删依赖 1$ yarn workspace [packageNameA] add [packageNameB] // packageNameA是指定安装依赖的包名，packageNameB是公共的包名或者项目内的包名 1$ yarn workspace [packageName] remove [packageName] 当项目依赖凌乱的时候，可以使用命令清理依赖 1$ lerna clean 其余还有一些命令如下，更多命令参考lerna 123lerna ls // 列出仓库中包信息lerna changed // 查看项目变动lerna exec // 执行命令 12lerna run &lt; script &gt; -- [..args] # 运行所有包里面的有这个script的命令$ lerna run --scope my-component test 1yarn workspaces info // 查看项目内信息 构建使用lerna run命令构建项目 1$ lerna run build // 会执行子包中build命令构建 发布123$ lerna publish # 发布自上一个版本以来发生了变化的包$ lerna publish from-git # 发布当前提交中标记的包$ lerna publish from-package # 发布注册表中没有最新版本的包 在运行时，该命令做了下面几件事中的一个： 发布自上一个版本以来更新的包(背后调用了 lerna version)。 这是 lerna 2.x 版本遗留下来的。 发布在当前提交中标记的包(from-git)。 发布在最新提交时注册表中没有版本的包(from-package)。 发布在前一次提交中更新的包(及其依赖项)的“金丝雀(canary)”版。 注意Lerna 永远不会发布标记为 private 的包（package.json 中的”private“: true） 在所有的发布过程中，都有生命周期在根目录和每个包中运行(除非使用了--ignore-scripts)。 请查看每个包的配置以了解发布作用域限定的包、自定义注册表和自定义标记的详细信息。 不支持只发布某个 packagelerna 官方不支持仅发布某个 package，见 issues/1691，如果需要，只能自己手动的进入 package 进行发布，这样 lerna 自带的各种功能就需要手动完成且可能和 lerna 的功能相互冲突 由于 lerna 会自动的监测 git 提交记录里是否包含指定 package 的文件修改记录，来确定版本更新，这要求设置好合理的 ignore 规则（否则会造成频繁的，无意义的某个版本更新），好处是其可以自动的帮助 package 之间更新版本 例如如果pkg-b 依赖了 pkg-a，如果 pkg-a 发生了版本变动，会自动的将 pkg-b 的对 pkg-a 版本依赖更新为 pkg-a 的最新版本。 如果 pkg-b 发生了版本变动，对 pkg-a 并不会造成影响。 版本迭代lerna 通过 version 命令来为各个模块进行版本迭代。基本命令如下： 1$ lerna version [major | minor | patch | premajor | preminor | prepatch | prerelease] 如果不选择此次迭代类型，则会进入交互式的提示流程来确定此次迭代类型 例如： 123$ lerna version 1.0.1 # 按照指定版本进行迭代$ lerna version patch # 根据 semver 迭代版本号最后一位$ lerna version # 进入交互流程选择迭代类型 自动生成 CHANGELOG当您使用这个参数运行时，lerna version将使用传统的提交规范来确定版本并生成 CHANGELOG.md 文件 1$ lerna version --conventional-commits 自动确立了版本更新 经测试 version_bump 是依赖于文件检测和 subject 结合，并不依赖于 scope，scope 的作用是用来生成 changelog 的吧，即如果是修改了 pkg-b 的文件，但是 commit 记录写的是 fix(pkg-a)，lerna 是会生成 pkg-b 的版本更新，并不会去更新 pkg-a 的版本 手动选择发布版本如果 git commit message 发现不太靠谱，且无法修改的话，那么需要手动的确认新版本，version 默认是手动选择版本 1$ lerna version version 成功后会自动的推送到主分支 lerna version 自动生成的提交格式为“ publish xxx”,并不符合 conventional-commit 规范，因此需要加以修改，我们通过 message 参数可以修改自动生成的提交记录 123456789101112// lerna.json{ &quot;packages&quot;: [&quot;packages/*&quot;], &quot;version&quot;: &quot;independent&quot;, &quot;npmClient&quot;: &quot;yarn&quot;, &quot;useWorkspaces&quot;: true, &quot;command&quot;: { &quot;publish&quot;: { &quot;message&quot;: &quot;chore: publish&quot; } }} 例子项目例子可参考eg 参考链接 lerna lerna 中文 基于 Lerna 管理 packages 的 Monorepo 项目最佳实践 基于 lerna 和 yarn workspace 的 monorepo 工作流 Lerna 中文教程详解 大前端项目代码重用，也许 lerna 是最好的选择 使用 Lerna、Yarn 管理 Monorepo 项目","link":"/blogs/articles/lerna/"},{"title":"Mac 上的 APP 推荐","text":"值得推荐的 mac 软件 开发相关 IDEA：编辑器 vscode：编辑器 sourceTree：git GUI Charles：HTTP 信息抓包工具 Postman：测试 Web API &amp; HTTP iTerm2：强大的终端神器 Sequel Pro：My Sql 管理页面 Redis Desktop Manager：Redis 管理页面 Dash 程序员的 API 文档查询利器 基本软件 Alfred （神器 Bartender （Menubar 菜单栏管理小助手 系统清理 CleanMyMac X App Cleaner &amp; Uninstaller（应用深度清理卸载工具 Typora （markdown 书写工具 Upic（Mac 图床客户端 截图 xnip (截图) 带有滚动效果，推荐 LICEcap （录制 gif） gifox (录制 gif，无点击效果) Snipaste （截图） Text Scanner（将图片上文字内容转换成可编辑文本） Kap (屏幕录像&amp;&amp;录制 gif) 带有点击效果，推荐 时间管理 OmniFocus Recess （时间管理，强制休息） 绘图软件 OmniGraffle 团队管理，任务管理 teambition 笔记、知识库 notion 思维导图 xmind 幕布 TeamView（远程操作 1Password （保存密码 outlook（邮箱 The Unarchiver（解压缩工具 ShadowsocksX-NG-R8（Vpn 屏保 机械手表 WatchOSX 倒计时 CountDown 翻页式钟表 fliqlo Sip（屏幕取色工具 IINA（视频播放工具 Paste（剪贴板 ScreenFlow（屏幕录像&amp;&amp;视频剪辑 KeyCastr（显示按键操作 Xscope (强大的设计辅助软件，标尺) Reeder（RSS 订阅器新闻阅读器 Yoink（一款移动复制文件效率工具","link":"/blogs/articles/mac-apps/"},{"title":"myBlogTestEmail","text":"","link":"/blogs/articles/myBlogTestEmail/"},{"title":"github-actions入门","text":"GitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。 GitHub Actions 简介GitHub Actions 帮助您自动完成软件开发周期内的任务。 GitHub Actions 是事件驱动的，意味着您可以在指定事件发生后运行一系列命令。 例如，每次有人为仓库创建拉取请求时，您都可以自动运行命令来执行软件测试脚本。 此示意图说明如何使用 GitHub Actions 自动运行软件测试脚本。事件会自动触发其中包作业的工作流程。 然后，作业使用步骤来控制操作运行的顺序。 这些操作是自动化软件测试的命令。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方！ GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName/repoName的语法引用 action。比如，actions/setup-node就表示github.com/actions/setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com/actions 里面。 既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。 actions123actions/setup-node@74bc508 # 指向一个 commitactions/setup-node@v1.0 # 指向一个标签actions/setup-node@master # 指向一个分支 基础概念GitHub Actions 有一些自己的术语。 workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 step（步骤）：每个 job 由多个 step 构成，一步步完成。 action （动作）：每个 step 可以依次执行一个或多个命令（action）。 虚拟环境GitHub 托管的运行器是由安装了 GitHub Actions 运行器应用程序的 GitHub 托管的虚拟机。 GitHub 提供使用 Linux、Windows 和 macOS 操作系统的运行器。 GitHub Ac­tions 为每个任务 (job) 都提供了一个虚拟机来执行，每台虚拟机都有相同的硬件资源： 2 核 CPU 7 GB RAM 内存 14 GB SSD 硬盘空间 虚拟环境 YAML 工作流程标签 Windows Server 2019 windows-latest 或 windows-2019 Ubuntu 20.04 ubuntu-20.04 Ubuntu 18.04 ubuntu-latest 或 ubuntu-18.04 Ubuntu 16.04 ubuntu-16.04 macOS Big Sur 11.0 macos-11.0 macOS Catalina 10.15 macos-latest 或 macos-10.15 注：Ubuntu 20.04 虚拟环境目前仅作为预览提供。 ubuntu-latest YAML 工作流程标签仍使用 Ubuntu 18.04 虚拟环境。 使用限制： 每个workflow的运行时限为 72 小时 每小时可以调用1000次 GitHub API 。 每个 job 最多可以执行6个小时。 免费版的用户最大支持20个 job 并发执行，macOS 最大只支持5个。 私有仓库 Linux 运行器每月累计使用时间为2000分钟，超过后$ 0.008/分钟，公共仓库则无限制。 注： 虽然名称叫持续集成，但当所有任务终止和完成时，虚拟环境内的数据会随之清空，并不会持续。即每个新任务都是一个全新的虚拟环境。 WorkflowGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml or .yaml，比如foo.yml or foo.yaml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml or .yaml文件，就会自动运行该文件。 workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段： name 工作流程的名称。 GitHub 在仓库的操作页面上显示工作流程的名称。 如果省略 name，GitHub 将其设置为相对于仓库根目录的工作流程文件路径。 name1name: GitHub Actions Demo on 必要 触发workflow的 GitHub 事件的名称。 你可以提供单一事件 string、事件的 array、事件 types 的 array 或事件配置 map，以安排工作流程的运行，或将工作流程的执行限于特定文件、标记或分支更改。 有关可用事件的列表，请参阅“触发工作流程的事件” 使用单一事件 Example using a single event1on: push 上面代码指定，push事件触发 workflow。 使用事件列表的示例 Example using a list of events1on: [push, pull_request] 上面代码指定，push事件或pull_request事件都可以触发 workflow。 完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。 on.&lt;push|pull_request&gt;.&lt;tags|branches&gt; 指定触发事件时，可以限定分支或标签。 1234on: push: branches: - master 上面代码指定，只有master分支发生push事件时，才会触发 workflow。 jobs workflow运行包括一项或多项jobs。 jobs默认是并行运行。 要按顺序运行作业，您可以使用 &lt;job_id&gt;needs 关键词在其他job上定义依赖项。 每个作业在 runs-on 指定的运行器环境中运行。 jobs.&lt;job_id&gt;.name workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。 jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。 12345jobs: my_first_job: name: My first job my_second_job: name: My second job 上面代码的jobs字段包含两项任务，job_id分别是my_first_job和my_second_job。 jobs.&lt;job_id&gt;.needs needs字段指定当前任务的依赖关系，即运行顺序。 123456jobs: job1: job2: needs: job1 job3: needs: [job1, job2] 上面代码中，job1必须先于job2完成，而job3等待job1和job2的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。 jobs.&lt;job_id&gt;.runs-on runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。 123- ubuntu-latest，ubuntu-18.04或ubuntu-16.04- windows-latest，windows-2019或windows-2016- macOS-latest或macOS-10.14 下面代码指定虚拟机环境为ubuntu-18.04。 1runs-on: ubuntu-18.04 jobs.&lt;job_id&gt;.steps steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。 123- jobs.&lt;job_id&gt;.steps.name：步骤名称。- jobs.&lt;job_id&gt;.steps.run：该步骤运行的命令或者 action。- jobs.&lt;job_id&gt;.steps.env：该步骤所需的环境变量。 下面是一个完整的 workflow 文件的范例。 workflow12345678910111213141516name: Greeting from Monaon: pushjobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 上面代码中，steps字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。 jobs.&lt;job_id&gt;.steps[*].uses 选择要作为job中step的一部分运行的操作。 操作是一种可重复使用的代码单位。 你可以使用工作流程所在仓库中、公共仓库中或发布 Docker 容器映像中定义的操作。 示例123456789steps: # Reference a specific commit - uses: actions/setup-node@74bc508 # Reference the major version of a release - uses: actions/setup-node@v1 # Reference a minor version of a release - uses: actions/setup-node@v1.2 # Reference a branch - uses: actions/setup-node@main 更多uses使用示例参考官网 示例一个简单的workflow文件示例workflow example123456789101112131415161718192021222324252627name: Hello Worldon: push: branches: - mainjobs: my_first_job: name: My first job runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@main - name: Run a single-line script run: echo &quot;Hello World!&quot; my_second_job: name: My second job runs-on: macos-latest steps: - name: Run a multi-line script env: MY_VAR: Hello World! MY_NAME: P3TERX run: | echo $MY_VAR echo My name is $MY_NAME 上面这个 workflow 文件的要点如下。 整个流程在main分支发生push事件时触发。 有两个个job，一个运行在虚拟机环境ubuntu-latest。一个运行在macos-latest My First Job 第一步是获取源码，使用的 action 是actions/checkout。 第二步是运行一个简单的脚本：echo &quot;Hello World!&quot; My Second Job 设定环境变量 MY_VAR 和MY_NAME 运行脚本打印环境变量 保存上面的文件后，将整个仓库推送到 GitHub。 GitHub 发现了 workflow 文件以后，就会自动运行。你可以在网站上实时查看运行日志，日志默认保存30天。 示例文件运行截图： react 项目发布到Github Pages示例项目需要将构建成果发到 GitHub 仓库，因此需要 GitHub 密钥。按照官方文档，生成一个密钥。然后，将这个密钥储存到当前仓库的Settings/Secrets里面。 在这个仓库的.github/workflows目录，生成一个 workflow 文件，名字可以随便取，这个示例是react-cli.yml。 我们选用一个别人已经写好的 action：JamesIves/github-pages-deploy-action，它提供了 workflow 的范例文件，直接拷贝过来就行了（查看源码） react-cli123456789101112131415161718192021222324name: github-test-actions上的React项目部署到github pageson: push: branches: - react-branchjobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout 🛎️ uses: actions/checkout@v2 with: persist-credentials: false - name: Install and Build 🔧 run: | npm install npm run build - name: Deploy 🚀 uses: JamesIves/github-pages-deploy-action@3.7.1 with: ACCESS_TOKEN: ${{ secrets.REACT_WORKFLOW_TOKEN }} BRANCH: gh-pages # The branch the action should deploy to. FOLDER: build # The folder the action should deploy. 整个流程在react-branch分支发生push事件时触发。 只有一个job，运行在虚拟机环境ubuntu-latest。 第一步是获取源码，使用的 action 是actions/checkout。 第二步是安装与构建。 第三步是部署，使用的 action 是JamesIves/github-pages-deploy-action，使用三个变量，分别为 GitHub 密钥、发布分支、构建成果所在目录。其中，只有 GitHub 密钥是变量，需要写在双括号里面，其他三个都可以直接写在文件里。 保存上面的文件后，将整个仓库推送到 GitHub。 等到 workflow 运行结束，访问 GitHub Page，会看到网页已经部署到指定网址上了。 参考链接 GitHub Actions GitHub Actions 入门教程 GitHub 托管的运行器的规格 GitHub 使用限制、计费和管理 GitHub 操作的工作流程语法 五分钟了解 YAML actions/checkout github-pages-deploy-action","link":"/blogs/articles/start-github-actions/"},{"title":"终端如何挂代理","text":"本文将介绍终端是如何挂代理的。 前提首先你需要类似于shadowsocksX-NG-R8的代理软件，本文以shadowsocksX-NG-R8为例 正文打开shdowsocks为代理模式。 以zsh作为说明 .zshrc1$ vim ~/.zshrc 第一种： 添加如下代理配置: edit12345678910111213# where need proxyproxy () { export http_proxy=&quot;socks5://127.0.0.1:1086&quot; export https_proxy=&quot;socks5://127.0.0.1:1086&quot; echo &quot;Socks Proxy on&quot;}# where need noproxynoproxy () { unset http_proxy unset https_proxy echo &quot;Socks Proxy off&quot;} 第二种： edit123# proxy listalias proxy='export all_proxy=socks5://127.0.0.1:1086'alias noproxy='unset all_proxy' 注：两种方式皆可，127.0.0.1:1086取自高级设置 :wq保存退出 .zshrc1$ source ~/.zshrc 验证是否proxy成功: 12345678910$ curl cip.ccIP : 101.81.77.200地址 : 中国 上海运营商 : 电信数据二 : 上海市 | 电信数据三 :URL : http://www.cip.cc/101.81.77.200 执行proxy: 1$ proxy 123456789$ curl cip.ccIP : 42.200.244.149地址 : 中国 香港 pccw.com数据二 : 香港 | 电讯盈科商用网络数据三 : 中国香港 | 电讯盈科URL : http://www.cip.cc/42.200.244.149 如果cip.cc不能用，可以换个类似的站点查询 如果不需要走代理，执行： 123$ noproxy$ curl cip.ccIP : 101.81.77.200 参考链接 Mac OSX 终端走 shadowsocks 代理 #18","link":"/blogs/articles/terminal-proxy/"},{"title":"uPic 图床配置教程 - Github","text":"简介uPic(upload Picture) 是一款 Mac 端的图床(文件)上传客户端，可将图片、各种文件上传到配置好的指定提供商的对象存储中。然后快速获取可供互联网访问的文件 URL。 配置项说明 用户名: Github 用户名。例如：我的 Github 主页https://github.com/MrSeaWave ，我的用户名就是MrSeaWave 仓库名: 需要储存上传文件的仓库名称。例如：我的仓库地址为https://github.com/MrSeaWave/figure-bed-profile ，仓库名称就是figure-bed-profile 分支: 分支名称，默认是main，如果是其他分支，就必须先创建好分支，才能上传 Token: Github 的个人访问令牌（Personal access tokens） 域名: 默认可不设置域名，会使用 Github 默认的访问地址。当你的仓库开启了pages功能，并配置好了自定义域名时，这里就可以使用你的自定义域名 使用默认 CDN 加速访问: 勾选时会自动使用 jsdelivr CDN 进行加速访问 保存路径: 文件储存的路径（包括文件夹）。 支持 {year} {month} {day} {hour} {minute} {second} {since_second} {since_millisecond} {random} {filename} {.suffix} 等变量。比如：上传的图片为 uPic.jpg，设定为 “uPic/{filename}{.suffix}”，则会保存到 “uPic/uPic.jpg”。 Token 获取方式 进入Github Token 创建页面 勾选 repo 访问权限。然后滚动页面到底部，点击Generate token按钮来生成 token。 复制生成好的 Token 值到 uPic token 输入框。注意：此 Token 只会显示一次！请务必保存好，否则之后丢失了，就得重新创建了。 最终效果保存一下，在菜单栏-图床栏选中刚刚配置好的 Github 图床，上传一张图片试试吧。上传成功后，Github 仓库就会出现你刚上传的文件啦","link":"/blogs/articles/upic-github/"},{"title":"vs-code“实用插件”","text":"在使用vs-code时，整理了一些好用的vs-code插件分享。 基础必备Chinesevscode编辑器汉化包，安装后，在 locale.json 中添加 &quot;locale&quot;: &quot;zh-cn&quot;，即可载入中文（简体）语言包。 Auto Rename Tag自动重命名成对的HTML标记，修改开始标签，结束标签会同步修改。 Auto Close Tag自动闭合HTML/XML标签 HTML SnippetsHTML 代码片段，该插件可为你提供 html 标签的代码提示，不用键入尖括号了。 Bracket Pair Colorizer该插件可以为你把成对的括号做颜色区分，并且提供一根连接线。方便我们审阅代码结构。 CSS Peekcss 样式查看器，可快速查看我们的 css 样式，非常方便快捷。 Npm Intellisense可自动完成导入语句中的 npm 模块。 open in browser快速打开html文件到浏览器预览。 Debugger for Chrome调试工具，必装；具体使用查看官网 vscode-icons提供了非常漂亮的目录树图标主题。 Material Icon Theme提供了非常漂亮的目录树图标主题。（这款最爱。 Atom One Dark ThemeOne Dark Theme based on Atom。 Dracula Official吸血鬼主题。 Path Intellisense自动提示文件路径，支持各种快速引入文件。 Image preview鼠标悬浮在链接上可及时预览图片。 Highlight Matching Tag点击某 Tag 时对应的 Tag 下会有下划线标示，比较实用； Beautify在代码文件右键鼠标一键格式化 html,js,css JavaScript (ES6) code snippetsES6 语法智能提示，以及快速输入。 VeturVScode官方钦定 Vue 插件，Vue开发者必备。内含语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger等实用功能。 indent-rainbow用颜色填充缩进，非常直观，如果有缩进错误还会变成红色。（ 对写 Nim or Python 用处极大。 代码风格规范Prettier - Code formatterPrettier 是一个“有态度”的代码格式化工具。，prettier支持我们大前端目前大部分语言处理，包括JavaScript 、Flow、 TypeScript 、CSS 、SCSS 、Less 、JSX 、Vue 、GraphQL 、JSON 、Markdown ESlint规范 js 代码书写规则，如果觉得太过严谨，可自定义规则。 Code Spell Checker是拼写检查程序，检查不常见的单词，如果单词拼写错误，会给出警告提示。 koroFileHeader在vscode中用于生成文件头部注释和函数注释的插件，经过多版迭代后，插件：支持所有主流语言，功能强大，灵活方便，文档齐全，食用简单！ Better Align代码书写的整洁，工整往往是衡量一个程序员素养的标准，这款插件可以让你的代码更排版优雅。 change-case通常我们对一个变量的命名可能是驼峰，可能是全大写，又或是下划线，这里可通过这个插件解决变量命名规范的问题。 选中变量配合组合键[Command+Shift+p]，输入对应格式即可。 1234567891011121314151617extension.changeCase.commands：列出所有“更改案例”命令，如果仅选择一个单词，则带有预览extension.changeCase.camel：更改大小写'camel'：转换为字符串，并用下一个字母大写表示分隔符extension.changeCase.constant：更改大小写“常量”：转换为大写字母，下划线分隔字符串extension.changeCase.dot：更改大小写的“点”：转换为小写，句点分隔的字符串extension.changeCase.kebab：更改大小写“ kebab”：转换为小写字母，用破折号分隔的字符串（参数名的别名）extension.changeCase.lower：更改大小写为“小写”：转换为小写的字符串extension.changeCase.lowerFirst：更改大小写“ lowerFirst”：转换为首字母小写的字符串extension.changeCase.no：转换没有任何大小写的字符串（小写字母，空格分隔）extension.changeCase.param：更改大小写为'param'：转换为小写字母，用破折号分隔的字符串extension.changeCase.pascal：更改大小写“ pascal”：转换为以与camelCase相同的方式表示的字符串，但首字母也大写extension.changeCase.path：更改大小写的“路径”：转换为小写，用斜杠分隔的字符串extension.changeCase.sentence：更改大小写的“句子”：转换为小写的空格分隔的字符串extension.changeCase.snake：更改大小写“ snake”：转换为小写字母，下划线分隔字符串extension.changeCase.swap：更改大小写“交换”：转换为每个大小写相反的字符串extension.changeCase.title：更改大小写“标题”：转换为以空格分隔的字符串，每个单词的第一个字符均大写extension.changeCase.upper：更改大小写为大写：转换为大写字符串extension.changeCase.upperFirst：更改大小写为“ upperFirst”：转换为首字母大写的字符串 Better Comments丰富注释颜色，让注释也具有生命力，如需自定义样式，需要写入配置代码。 1234567891011配置代码&quot;better-comments.tags&quot;: [ { &quot;tag&quot;: &quot;*&quot;, &quot;color&quot;: &quot;#98C379&quot;, &quot;strikethrough&quot;: false, &quot;backgroundColor&quot;: &quot;transparent&quot; }]使用// * 绿色的高亮注释 TODO Tree我们经常会在代码中使用TODO来标记我们的代码，提高可读性，TODO Tree这款插件提供了可视化窗口来查看和管理我们的TODO Tree 其他插件（开发神器GitLensGitLens可以帮助你更好地理解代码。快速查看更改行或代码块的对象，功能强大，功能丰富且高度可定制，可以满足你的需求 GitHistoryGitHistory可查看和搜索 git 日志以及图形和详细信息，同时还支持分支比较，分支管理等操作，非常方便。 Partial Diff文件比较是一个很常见的场景，如果光凭我们肉眼分别的话，累人不说还容易出错。 Partial Diff的出现就正好解决了这个问题。 Markdown All in One这款神器可以让我们在vscode里面快乐的书写Markdown，功能强大。提供了丰富的快捷键，可边写边看，轻松转化为html或pdf文件，十分好用，强烈推荐。 vscode-drawio这款神器可以让我们在vscode里面快乐的画流程图。新建 .drawio 后缀文件并拖入 vscode 中。 Polacode-2020这款神器可以将我们的代码转化成一张逼格满满的图片，在写文章或者代码分享的时候。抛出一张这样的图片，可比随手截图体面多了。 carbon-now-sh也是一款将代码转换成图片的插件，不过它会打开carbon.now.sh网站 REST Client这款神器可以让我们在vscode里面进行接口调试，提供丰富的 api 配置方式，让我们不用离开编辑器也可以随时调用接口调试。 新建一个.http文件，写下基本的测试代码，点击 Send Request即可在右边窗口查看接口返回结果，非常 nice。 Browser Preview可以让我们在vscode里面打开浏览器，一边编码一边查看。 JavaScript Booster这款神器可以在我们代码写的不规范或者有待调整的地方，在光标聚焦后，会有一个小灯泡，只需跟随灯泡 💡，会提示对应的不合理原因和改进方案，极大的提高了我们的代码优雅度。 当在JavaScript（或TypeScript / Flow）中编辑代码时，此VS Code扩展提供了各种代码操作（快速修复）。只需注意左侧的灯泡 💡，然后按一下它即可了解如何在光标下转换代码。 Settings Sync让我们的vscode配置同步到云端，当我们跟换电脑或者再次安装vscode的时候，只需要登录账号即可同步配置了，而不用再次从头开始。（针对老版本的vscode） 预览版vscode自带配置同步功能，可以通过 Microsoft 账户或 GitHub 账户进行多机器同步。具体可参考官网 Vim如果你是vim重度用户，那么这款插件必不可少。 Live Share可以使您能够与他人实时进行协作式编辑和调试，无论您使用的是哪种编程语言或正在构建的应用程序类型。具体使用细节可查看官网 Remote Development远程开发必备扩展安装（划时代的产品）。会为你安装包括 Remote-SSH 等全部远程开发使用的扩展。具体搭建可参考VS Code Remote 环境搭建","link":"/blogs/articles/vs-code-plugins/"},{"title":"vscode插件project-manager使用","text":"在项目开发的时候，我们经常需要同时操作多个项目，经常需要切换项目。 以前的方式 在工具栏中点击文件，打开，选择本地项目的目录 / 新建窗口 如果有最近打开的项目，点击打开最近的文件 这两种方式对于需要经常切换项目时，比较耗时 为解决这个问题，VSCode 提供了 Project Manager 插件管理，开发时常用的项目。 Project Manager 管理项目可用命令 Project Manager: Save Project 将当前文件夹另存为新项目 Project Manager: Edit Project 手动编辑项目（projects.json） Project Manager: List Projects to Open 列出所有已保存/检测到的项目并选择一个 Project Manager: List Projects to Open in New Window 列出所有已保存/检测到的项目，然后选择一个在新窗口中打开 Project Manager: Refresh Projects 刷新缓存的项目 保存项目command+ shift + p 打开配置文件，输入 Project Manager: Save Projects 您可以随时将当前项目保存在管理器中。你只需要输入一个名字。它甚至会自动为你建议一个名字:) 按 Enter 键后，右下角弹出保存成功提示。 编辑项目为了更轻松地自定义项目列表，您可以 projects.json 直接在 Code 中编辑文件。只需执行 Project Manager: Edit Projects和projects.json 文件被打开。这很简单，我就手动添加了一个 blogs 项目： 确保 JSON 文件格式正确。否则，项目管理器将无法打开它，并且会出现类似这样的错误消息。在这种情况下，您应该使用 Open File 按钮来修复它。 刷新项目command+ shift + p 打开配置，输入 Project Manager: Refresh Projects 刷新项目 项目列表刷新之后，左侧导航栏，多出一个文件夹图标，用于管理项目，点击其中一个，自动切换项目。 可用设置设置插件的可配置项，在 首选项 - 设置 - 拓展 - Project Manager Configuration 位置 举例：您可以选择项目的排序方式 1&quot;projectManager.sortList&quot;: &quot;Name&quot; Saved：您保存项目的顺序 Name：您为项目键入的名称 Path：项目的完整路径 Recent：最近使用的项目","link":"/blogs/articles/vscode-project-manager/"},{"title":"hexo new 生成新的文章","text":"介绍关于如何新建博客，官网已经有了明确的介绍： 你可以执行下列命令来创建一篇新文章或者新的页面。 命令行1$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 这句话有几个地方需要解释一下： layout是什么？layout的意思是布局，hexo博客安装成功后，在默认的根部录下，有一个scaffolds文件夹，里面有个 3 个文件，分别是draft.md,page.md,post.md。这 3 个文件就是默认的 layout 。这三个布局分别会有什么样的作用和效果，我们会在后面的内容中进行详细说明。 如果不提供 layout 的话，也可以生成博客，不过默认的 layout 是在 _config.yml 中的配置。一般情况下，如果没有更改过任何 _config.yml 中的内容的话，默认的 layout 是 post 如果 title 包含空格的话， title 需要用引号包裹起来。也就是意味着，如果 title 没有空格的话，可以不使用引号。 假设我们想要写一篇名为 myBlog 的博客，如果输入完整的命令的话，应该是： hexo new post &quot;myBlog&quot;。但是因为默认情况下，我们的 layout 就是post，所以我们可以将 post 省略掉，写为 hexo new &quot;myBlog&quot; 。又因为我们的博客名字中没有空格，因此可以将省略号去掉，写为hexo new myBlog。这个命令已经是简化到不能再简化的命令了。而如果我们的博客名称是 my first blog，因为名称包含了空格，所以我们的命令就必须将博客名称包裹起来，也就是说最简化的命令就是 hexo new &quot;my first blog&quot; 。 这就是为什么很多网上的攻略说新生成一篇文章时用hexo new &lt;title&gt;的命令的原因，这个命令没错，但是只是大部分的情况，而不是完整的命令。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts layout 为 post 的情况以上面的情况为例，我们的命令是 hexo new post myBlog ，执行这个命令之后，你会发现命令行会有如下提示： 它告诉你，在根目录的下的 source 文件夹中创建了一个 _post 文件夹，并且在内生成了一个myBlog.md的文件。打开对应的文件夹，你会发现myBlog.md的文件，这就是你新生成的文件。你可以通过某种支持markdown的编辑器打开这个文件，然后使用markdown格式的方法书写这篇博客。 layout 为 draft 的情况Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹。 接下来我们使用hexo new draft myDraftBlog，生成myDrafaBlog.md文件，这个md文件是草稿状态，也就是说，这篇文章仅仅是作为你的草稿而不是正式稿，所以不会发表在博客主页上。草稿就是需要你不断完善的文章，知道有一天你觉得这篇文章可以正式发表了，你可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定layout 来指定布局。 publish1$ hexo publish [layout] &lt;title&gt; （草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。） 执行hexo publish draft myDraftBlog，你就会发现，source/_draft文件夹下的myDraftBlog.md文件消失了，而在_post文件夹下你会找到myDraftBlog.md文件。 layout 为 page 的情况我们可以尝试一下下面这个命令hexo new page &quot;about&quot;，这个时候你打开source文件夹你会发现一个about的文件夹，里面会有一个index.md的文件。打开http://localhost:4000/about，这个时候你就会发现你刚才编辑的index.md的内容会出现在这里。 layout 为 page的时候，其实就是相当于生成一个新的路径，也就是我们说的url的path，或者也可以称作路由。通过这种方式，我们可以把我们的博客再进行细分各个内容版块，更有条理的组织我们的博客。 Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： eg1234---title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签 （不适用于分页） categories 分类 （不适用于分页） permalink 覆盖文章网址 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 eg12345categories:- Diarytags:- PS3- Games 如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。 分类Eg1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life] 此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。 标签插件具体内容参考官网 参考链接 hexo 写作","link":"/blogs/articles/writing-hexo/"},{"title":"微信小程序云开发获取用户手机号","text":"在网上搜索时，大部分微信小程序云开发获取手机号码的例子还都是需要通过code获取session_key来解密信息取得手机号码，总感觉哪里不对，官网上都已经说过，云开发是自动鉴权的，不应该还要解密,因此下面介绍如何使用云开发获取用户信息数据。 具体步骤1，页面 cellphone.wxml cellphone.wxml1&lt;button open-type=&quot;getPhoneNumber&quot; bindgetphonenumber=&quot;getPhoneNumber&quot;&gt;&lt;/button&gt; 2，文件cellphone.js cellphone.js12345678910111213141516Page({ getPhoneNumber(e) { console.log(e.detail); wx.cloud .callFunction({ name: &quot;openapi&quot;, data: { action: &quot;getcellphone&quot;, id: e.detail.cloudID } }) .then(res =&gt; { console.log(&quot;res: &quot;, res); }); }}); 3，云函数 openapi 的index.js index.js123456789101112131415161718192021// 云函数入口文件const cloud = require(&quot;wx-server-sdk&quot;);cloud.init();// 云函数入口函数exports.main = async (event, context) =&gt; { switch (event.action) { case &quot;getcellphone&quot;: { return getCellphone(event); } default: { return; } }};async function getCellphone(event) { const res = await cloud.getOpenData({ list: [event.id] }); return { res, event };} 调用后res数据如下 res123456789101112131415161718{ &quot;list&quot;: [ { &quot;cloudID&quot;: &quot;***********&quot;, &quot;data&quot;: { &quot;phoneNumber&quot;: &quot;****&quot;, // 用户绑定的手机号（国外手机号会有区号） &quot;purePhoneNumber&quot;: &quot;******&quot;, // 没有区号的手机号 &quot;countryCode&quot;: &quot;86&quot;, // 区号 &quot;watermark&quot;: { &quot;timestamp&quot;: 1612332238, &quot;appid&quot;: &quot;********&quot; } } } ], &quot;errMsg&quot;: &quot;getOpenData:ok&quot;, &quot;errCode&quot;: 0} 全程不涉及code,session_key和加密解密啥事，即可获取到用户的手机号。 参考链接 微信小程序云开发获取手机号码 获取手机号| 微信开放文档 - 微信开放社区 - 腾讯 Cloud.getOpenData(list: string[]): Object","link":"/blogs/articles/wx-get-cellphone/"}],"tags":[{"name":"apple","slug":"apple","link":"/blogs/tags/apple/"},{"name":"gift","slug":"gift","link":"/blogs/tags/gift/"},{"name":"card","slug":"card","link":"/blogs/tags/card/"},{"name":"chrome","slug":"chrome","link":"/blogs/tags/chrome/"},{"name":"download","slug":"download","link":"/blogs/tags/download/"},{"name":"chromium","slug":"chromium","link":"/blogs/tags/chromium/"},{"name":"history","slug":"history","link":"/blogs/tags/history/"},{"name":"hexo","slug":"hexo","link":"/blogs/tags/hexo/"},{"name":"ci","slug":"ci","link":"/blogs/tags/ci/"},{"name":"js","slug":"js","link":"/blogs/tags/js/"},{"name":"export","slug":"export","link":"/blogs/tags/export/"},{"name":"export default","slug":"export-default","link":"/blogs/tags/export-default/"},{"name":"git","slug":"git","link":"/blogs/tags/git/"},{"name":"commit","slug":"commit","link":"/blogs/tags/commit/"},{"name":"cli","slug":"cli","link":"/blogs/tags/cli/"},{"name":"lint","slug":"lint","link":"/blogs/tags/lint/"},{"name":"github","slug":"github","link":"/blogs/tags/github/"},{"name":"proxy","slug":"proxy","link":"/blogs/tags/proxy/"},{"name":"vpn","slug":"vpn","link":"/blogs/tags/vpn/"},{"name":"empty","slug":"empty","link":"/blogs/tags/empty/"},{"name":"repository","slug":"repository","link":"/blogs/tags/repository/"},{"name":"configuration","slug":"configuration","link":"/blogs/tags/configuration/"},{"name":"questions","slug":"questions","link":"/blogs/tags/questions/"},{"name":"SEO","slug":"SEO","link":"/blogs/tags/SEO/"},{"name":"permalinks","slug":"permalinks","link":"/blogs/tags/permalinks/"},{"name":"hooks","slug":"hooks","link":"/blogs/tags/hooks/"},{"name":"husky","slug":"husky","link":"/blogs/tags/husky/"},{"name":"sourceTree","slug":"sourceTree","link":"/blogs/tags/sourceTree/"},{"name":"idea","slug":"idea","link":"/blogs/tags/idea/"},{"name":"prettier","slug":"prettier","link":"/blogs/tags/prettier/"},{"name":"tools","slug":"tools","link":"/blogs/tags/tools/"},{"name":"WebStorm","slug":"WebStorm","link":"/blogs/tags/WebStorm/"},{"name":"format","slug":"format","link":"/blogs/tags/format/"},{"name":"wx","slug":"wx","link":"/blogs/tags/wx/"},{"name":"install","slug":"install","link":"/blogs/tags/install/"},{"name":"rust","slug":"rust","link":"/blogs/tags/rust/"},{"name":"kill","slug":"kill","link":"/blogs/tags/kill/"},{"name":"lcasensor","slug":"lcasensor","link":"/blogs/tags/lcasensor/"},{"name":"dlp","slug":"dlp","link":"/blogs/tags/dlp/"},{"name":"lerna","slug":"lerna","link":"/blogs/tags/lerna/"},{"name":"monorepo","slug":"monorepo","link":"/blogs/tags/monorepo/"},{"name":"Mac","slug":"Mac","link":"/blogs/tags/Mac/"},{"name":"Apps","slug":"Apps","link":"/blogs/tags/Apps/"},{"name":"recommend","slug":"recommend","link":"/blogs/tags/recommend/"},{"name":"actions","slug":"actions","link":"/blogs/tags/actions/"},{"name":"workflow","slug":"workflow","link":"/blogs/tags/workflow/"},{"name":"terminal","slug":"terminal","link":"/blogs/tags/terminal/"},{"name":"upic","slug":"upic","link":"/blogs/tags/upic/"},{"name":"vs-code","slug":"vs-code","link":"/blogs/tags/vs-code/"},{"name":"plugins","slug":"plugins","link":"/blogs/tags/plugins/"},{"name":"ide","slug":"ide","link":"/blogs/tags/ide/"},{"name":"write","slug":"write","link":"/blogs/tags/write/"},{"name":"微信小程序","slug":"微信小程序","link":"/blogs/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"云开发","slug":"云开发","link":"/blogs/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"}],"categories":[{"name":"apple","slug":"apple","link":"/blogs/categories/apple/"},{"name":"chrome","slug":"chrome","link":"/blogs/categories/chrome/"},{"name":"hexo","slug":"hexo","link":"/blogs/categories/hexo/"},{"name":"js","slug":"js","link":"/blogs/categories/js/"},{"name":"git","slug":"git","link":"/blogs/categories/git/"},{"name":"configuration","slug":"hexo/configuration","link":"/blogs/categories/hexo/configuration/"},{"name":"idea","slug":"idea","link":"/blogs/categories/idea/"},{"name":"install","slug":"install","link":"/blogs/categories/install/"},{"name":"lcasensor","slug":"lcasensor","link":"/blogs/categories/lcasensor/"},{"name":"lerna","slug":"lerna","link":"/blogs/categories/lerna/"},{"name":"commit","slug":"git/commit","link":"/blogs/categories/git/commit/"},{"name":"Mac","slug":"Mac","link":"/blogs/categories/Mac/"},{"name":"github","slug":"github","link":"/blogs/categories/github/"},{"name":"vpn","slug":"vpn","link":"/blogs/categories/vpn/"},{"name":"upic","slug":"upic","link":"/blogs/categories/upic/"},{"name":"vs-code","slug":"vs-code","link":"/blogs/categories/vs-code/"},{"name":"write","slug":"hexo/write","link":"/blogs/categories/hexo/write/"},{"name":"小程序","slug":"小程序","link":"/blogs/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"rust","slug":"install/rust","link":"/blogs/categories/install/rust/"},{"name":"recommend","slug":"Mac/recommend","link":"/blogs/categories/Mac/recommend/"},{"name":"actions","slug":"github/actions","link":"/blogs/categories/github/actions/"},{"name":"github","slug":"upic/github","link":"/blogs/categories/upic/github/"},{"name":"plugins","slug":"vs-code/plugins","link":"/blogs/categories/vs-code/plugins/"},{"name":"微信小程序","slug":"小程序/微信小程序","link":"/blogs/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"rust","slug":"rust","link":"/blogs/categories/rust/"},{"name":"install","slug":"rust/install","link":"/blogs/categories/rust/install/"}]}