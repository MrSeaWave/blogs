{"pages":[{"title":"About me","text":".heimu { color: #000; background-color: #000; } .heimu:hover { color: #fff; } 95后前端开发一枚，爱好动漫，撸猫， 家有两只猫，一只蒂阿瑞（英短银渐层），一只逢坂大河（狸花猫），旅游，游戏，ps4（Fantasy_FishViy），switch党 独爱魂系游戏，欢迎一起来传火！ 2020年加入 如果青年 和朋友们一起搞事情，哇哈哈哈 博客主要写文章，技术 or 自己还没能解决的坑，但可能因为表述会有点问题，博客更多只是写给自己看的，如果发现不懂之处和可以改进的地方欢迎留言 🙏 本站文章如无特别声明，均为原创，转载请注明来源","link":"/blogs/about/index.html"},{"title":"留言板","text":"不留下点什么证明你来过吗~","link":"/blogs/messages/index.html"},{"title":"友人帐","text":"function changeFrameHeight(){ const ifm= document.getElementById(\"blogFriend\"); ifm.height=ifm.contentWindow.document.body.scrollHeight; }; window.onresize=function(){ changeFrameHeight(); }","link":"/blogs/friends/index.html"}],"posts":[{"title":"修复 CI 构建博客造成的更新时间错误","text":"当使用 Travis CI or Github Actions 自动化部署时，发现部署成功后，所有文章的更新时间都变成了此次提交修改的时间，但有些文章在上一次提交后是没有发生过任何修改的。 这是因为 git 在推送更新时，并不记录保存文件的访问时间、修改时间等元信息，（原因在这里）所以每次使用 git 把项目 clone 下来时，文件的时间都是克隆时的时间。又因为如果没有在 front-matter 中指定 updated，Hexo 会默认使用文件的最后修改时间作为文章的更新时间，所以会出现所有文章的更新时间都发生变化的情况。 总的来说，使用 git clone 下来的文件的时间都不是原来文件的时间，而自动化部署每次都需要 clone 源码才能进行后面的生成和部署操作，所以目前如果想正确显示更新时间。需要： 方法一：使用 updated 属性字段在文章中的front-matter中添加updated: 更新时间项 front-matter12345title: 修复 CI 构建博客造成的更新时间错误author: Seatoc: truedate: 2021-01-07 15:53:16updated: 2021-01-07 15:53:16 以后修改文件的话也只需修改updated项对应日期即可，但是这样有个弊端，完全需要靠自己自觉去修改更新时间，自己一旦忘掉，那么更新时间的意义也就荡然无存了，因此这里推荐第二种方法。 方法二：使用 git 推送时间如果你用的是Travis Ci的话，只需要在.travis.yml添加如下配置： .travis.yml123before_install: # Restore last modified time - 'git ls-files -z | while read -d '''' path; do touch -d &quot;$(git log -1 --format=&quot;@%ct&quot; &quot;$path&quot;)&quot; &quot;$path&quot;; done' 如果你用的是Github Actions的话，只需要在对应的yml添加如下配置： actions123456jobs: &lt;jobs_id&gt;: steps: - name: Restore file modification time run: | &quot;git ls-files -z | while read -d '' path; do touch -d \\&quot;$(git log -1 --format=\\&quot;@%ct\\&quot; \\&quot;$path\\&quot;)\\&quot; \\&quot;$path\\&quot;; done&quot; 当然git ls-files 如果不好用可以改成 find： bash1find source/_posts -name '*.md' | while read file; do touch -d &quot;$(git log -1 --format=&quot;@%ct&quot; &quot;$file&quot;)&quot; &quot;$file&quot;; done 实际上，clone 下来的文件的时间还是克隆时的时间，然后通过上面的命令，它将 clone 下来的文件的时间改成了该文件最近一次变动的推送时间（也即文件最后一次修改的 push 时间）。 注：如果github actions中使用actions/checkout@v2，请设定它的参数fetch-depth: 0，因为0表示获取所有分支和标签的所有历史记录。默认值为1 小知识： bash12345678# 获取 git 仓库中所有文件的最新修改时间git ls-tree -r --name-only HEAD | while read filename; do echo &quot;$(git log -1 --format=&quot;%ad&quot; -- $filename) $filename&quot;done# 获取 git 仓库中所有文件的最初创建时间git ls-tree -r --name-only HEAD | while read filename; do echo &quot;$(git log --format=&quot;%ad&quot; -- $filename | tail -1) $filename&quot;done 参考链接 GIT 获取文件最初创建及最新修改日期 How to retrieve the last modification date of all files in a git repository：介绍了如何获取 git 仓库中，所有文件的最新修改时间。 Finding the date/time a file was first added to a Git repository：介绍了如何获取 git 仓库中，所有文件最初的创建时间。 Hexo 相关问题和优化 The update time of the article is incorrect 修复 CI 构建博客造成的更新时间错误","link":"/blogs/articles/ci-hexo-update-time/"},{"title":"rust 安装","text":"Rust 通常被称为 rust-lang。Rust 是一个由 Mozilla Research 赞助的通用的、多范式、现代的、跨平台和开源系统编程语言。 它旨在实现安全性、速度和并发性等目标。 Rust 在语法上与 C++ 相似，但它的设计者希望它在保持性能的同时提供更好的内存安全性。 Rust 目前在许多组织中使用，例如 Firefox、Chef、Dropbox、Oracle、GNOME 等。 如何在 Mac 中安装 Rust 语言？我们可以通过多种方式安装 Rust，但以下是官方推荐的安装方式。 install12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | shinfo: downloading installerWelcome to Rust!This will download and install the official compiler for the Rustprogramming language, and its package manager, Cargo.Rustup metadata and toolchains will be installed into the Rustuphome directory, located at: /Users/xmly/.rustupThis can be modified with the RUSTUP_HOME environment variable.The Cargo home directory located at: /Users/xmly/.cargoThis can be modified with the CARGO_HOME environment variable.The cargo, rustc, rustup and other commands will be added toCargo's bin directory, located at: /Users/xmly/.cargo/binThis path will then be added to your PATH environment variable bymodifying the profile files located at: /Users/xmly/.profile /Users/xmly/.zshenvYou can uninstall at any time with rustup self uninstall andthese changes will be reverted.Current installation options: default host triple: x86_64-apple-darwin default toolchain: stable (default) profile: default modify PATH variable: yes1) Proceed with installation (default)2) Customize installation3) Cancel installation&gt;info: profile set to 'default'info: default host triple is x86_64-apple-darwininfo: syncing channel updates for 'stable-x86_64-apple-darwin'info: latest update on 2020-12-31, rust version 1.49.0 (e1884a8e3 2020-12-29)info: downloading component 'cargo' 4.1 MiB / 4.1 MiB (100 %) 3.3 MiB/s in 1s ETA: 0sinfo: downloading component 'clippy'info: downloading component 'rust-docs' 13.8 MiB / 13.8 MiB (100 %) 2.3 MiB/s in 6s ETA: 0sinfo: downloading component 'rust-std' 21.1 MiB / 21.1 MiB (100 %) 2.3 MiB/s in 9s ETA: 0sinfo: downloading component 'rustc' 50.8 MiB / 50.8 MiB (100 %) 2.3 MiB/s in 22s ETA: 0sinfo: downloading component 'rustfmt'info: installing component 'cargo'info: using up to 500.0 MiB of RAM to unpack componentsinfo: installing component 'clippy'info: installing component 'rust-docs' 13.8 MiB / 13.8 MiB (100 %) 3.4 MiB/s in 4s ETA: 0sinfo: installing component 'rust-std' 21.1 MiB / 21.1 MiB (100 %) 3.6 MiB/s in 5s ETA: 0sinfo: installing component 'rustc' 50.8 MiB / 50.8 MiB (100 %) 7.4 MiB/s in 7s ETA: 0sinfo: installing component 'rustfmt'info: default toolchain set to 'stable-x86_64-apple-darwin' stable-x86_64-apple-darwin installed - rustc 1.49.0 (e1884a8e3 2020-12-29)Rust is installed now. Great!To get started you need Cargo's bin directory ($HOME/.cargo/bin) in your PATHenvironment variable. Next time you log in this will be doneautomatically.To configure your current shell, run:source $HOME/.cargo/env 运行以下命令配置当前 shell。 source1$ source $HOME/.cargo/env 运行以下命令验证已安装的 Rust 版本。 rust version12$ rustc --versionrustc 1.49.0 (e1884a8e3 2020-12-29) 如何测试 Rust 编程语言安装 Rust 后，请按照以下步骤检查 Rust 语言是否正常工作。 创建一个文件并添加以下代码并保存。确保 Rust 文件始终以 .rs 扩展名结尾。 index1234$ vim index.rsfn main() { println!(&quot;Hello World&quot;);} 运行以下命令编译 rust 代码。 rust1$ rustc index.rs 上面的命令将在同一目录中创建一个可执行的 Rust 程序。 ls1234$ ls -lhtotal 760-rwxr-xr-x 1 xmly staff 375K 1 20 10:45 index-rw-r--r-- 1 xmly staff 41B 1 20 10:36 index.rs 运行 Rust 可执行文件得到输出。 run12$ ./indexHello World 好了！正常工作了。 参考链接 Rustup for managing Rust versions rust","link":"/blogs/articles/install-rust/"},{"title":"hexo 相关问题以及优化配置","text":"前言本文记录一些 hexo 出现的问题及其解决方案，以及相关配置 hexo 环境 env1234hexo: 5.3.0hexo-cli: 4.2.0os: Darwin 19.6.0 darwin x64node: 15.2.1 禁止爬虫跟踪外链搜索引擎的蜘蛛来爬取文章内容时，如果你的文章中有外部链接，它就会到外链的站点去爬取，有可能再也不会回来了。为了告诉搜索引擎不要跟踪这些外链，需要在这些链接标签中添加属性 rel=&quot;nofollow&quot; 或 rel=&quot;external nofollow&quot; 。 rel=&quot;nofollow&quot; 是通用格式，即是告诉搜索引擎不要跟踪此链接，rel=&quot;external nofollow&quot; 是更具体的写法，进一步告诉搜索引擎这是一个外部的链接，不要跟踪它。 我们可以使用 hexo-filter-nofollow 自动为 Hexo 博客中的外链添加 rel=&quot;external nofollow noreferrer&quot;的插件，从而改善你的网站的安全性和 SEO。 安装install1$ npm i hexo-filter-nofollow --save 编辑 _config.yml在 站点配置文件 _config.yml 末尾添加如下内容： _config.yml123456nofollow: enable: true field: site exclude: - &quot;exclude1.com&quot; - &quot;exclude2.com&quot; enable - 是否启用插件，默认值为 true field - 插件的处理范围，默认值为 site，可选 post 或 site post - 仅处理文章内容 site - 处理全站所有页面 exclude - 域名白名单，不同的子域名视为不同的域名（如 www） exclude1.com不包括 www.exclude1.com 或 en.exclude1.com 永久链接因链接层级过深、链接中包含中文、 title 变动导致链接也经常发生变动，这些都不利于 SEO 。 方法一：按照文件名称生成假设文章： md123456# source/_posts/lorem/hello-world.mdtitle: Hello World Pagedate: 2013-07-14 17:01:34categories: - foo - bar 根据官网介绍在_config.yml中设定： _config.yml123456# title: 文件名称 (relative to “source/_posts/“ folder)permalink: :title/# url:-----&gt; /lorem/hello-world/# name: 文件名称permalink: :name/# url:-----&gt; /hello-world/ 问题来了，如果按照文件名称生成永久链接的，我的文件格式都要是这类 英文字母.md 的格式。如果是中文中文.md那么就会变成/中文/，浏览器地址栏上很不美观，对 SEO 也不好。 有没有办法让 Markdown 文件用 你好世界.md 这类中文文件名保存，生成的永久链接格式又是 /hello-world/ 这种样式呢？ Markdown Front-matter 区域可以看到，我这里除了 title， date 以及 tags 外，自己添加了一个新的变量 customUrl ，这个新的变量用来保存每个文章的英文名字，这样一来可以有利于 SEO，二来可以缩短博客文章 URL 的层数。 front-matter123title: Hello World Page# 自定义的变量customUrl: custom-hello-world 再在 hexo 配置文件 _config.yml 中，把 permalink: 的值设为 :customUrl/ 。 _config.yml12permalink: :customUrl/# url:------&gt; /custom-hello-world/ 方法二：使用 hexo-abbrlink推荐使用插件 hexo-abbrlink 生成 permalink 。 安装install1$ npm install hexo-abbrlink --save 使用然后在配置文件_config.yml 中修改： _config.yml12345permalink: :abbrlink/#abbrlink配置abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 执行 hexo clean &amp;&amp; hexo g 重新生成静态文件后，源文件 front-matter 中会包含 abbrlink: xxx 。 如果文章中未指定 abbrlink: xxx，将会根据算法随机生成数字 这样就确保了链接的唯一化，只要不修改 md 文件的 abbrlink 的值，url 就永久不会改变。 使用这种方法生成 permalink 时，在每次提交修改前，最好先执行 hexo clean &amp;&amp; hexo g，确保提交前你所有的文章的 front-matter 中都包含 abbrlink ，避免因 title 的改变导致生成 abbrlink 不一致（如果已存在 abbrlink，就不会重新生成，不论title 是否发生变化）。 参考链接 Hexo 相关问题和优化 hexo-filter-nofollow - Hexo 官方的 nofollow 插件 Hexo 永久链接管理 永久链接（Permalinks） hexo-abbrlink","link":"/blogs/articles/hexo-configuration/"},{"title":"myBlogTestEmail","text":"","link":"/blogs/articles/myBlogTestEmail/"},{"title":"hexo new 生成新的文章","text":"介绍关于如何新建博客，官网已经有了明确的介绍： 你可以执行下列命令来创建一篇新文章或者新的页面。 命令行1$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 这句话有几个地方需要解释一下： layout是什么？layout的意思是布局，hexo博客安装成功后，在默认的根部录下，有一个scaffolds文件夹，里面有个 3 个文件，分别是draft.md,page.md,post.md。这 3 个文件就是默认的 layout 。这三个布局分别会有什么样的作用和效果，我们会在后面的内容中进行详细说明。 如果不提供 layout 的话，也可以生成博客，不过默认的 layout 是在 _config.yml 中的配置。一般情况下，如果没有更改过任何 _config.yml 中的内容的话，默认的 layout 是 post 如果 title 包含空格的话， title 需要用引号包裹起来。也就是意味着，如果 title 没有空格的话，可以不使用引号。 假设我们想要写一篇名为 myBlog 的博客，如果输入完整的命令的话，应该是： hexo new post &quot;myBlog&quot;。但是因为默认情况下，我们的 layout 就是post，所以我们可以将 post 省略掉，写为 hexo new &quot;myBlog&quot; 。又因为我们的博客名字中没有空格，因此可以将省略号去掉，写为hexo new myBlog。这个命令已经是简化到不能再简化的命令了。而如果我们的博客名称是 my first blog，因为名称包含了空格，所以我们的命令就必须将博客名称包裹起来，也就是说最简化的命令就是 hexo new &quot;my first blog&quot; 。 这就是为什么很多网上的攻略说新生成一篇文章时用hexo new &lt;title&gt;的命令的原因，这个命令没错，但是只是大部分的情况，而不是完整的命令。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts layout 为 post 的情况以上面的情况为例，我们的命令是 hexo new post myBlog ，执行这个命令之后，你会发现命令行会有如下提示： 它告诉你，在根目录的下的 source 文件夹中创建了一个 _post 文件夹，并且在内生成了一个myBlog.md的文件。打开对应的文件夹，你会发现myBlog.md的文件，这就是你新生成的文件。你可以通过某种支持markdown的编辑器打开这个文件，然后使用markdown格式的方法书写这篇博客。 layout 为 draft 的情况Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹。 接下来我们使用hexo new draft myDraftBlog，生成myDrafaBlog.md文件，这个md文件是草稿状态，也就是说，这篇文章仅仅是作为你的草稿而不是正式稿，所以不会发表在博客主页上。草稿就是需要你不断完善的文章，知道有一天你觉得这篇文章可以正式发表了，你可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定layout 来指定布局。 publish1$ hexo publish [layout] &lt;title&gt; （草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。） 执行hexo publish draft myDraftBlog，你就会发现，source/_draft文件夹下的myDraftBlog.md文件消失了，而在_post文件夹下你会找到myDraftBlog.md文件。 layout 为 page 的情况我们可以尝试一下下面这个命令hexo new page &quot;about&quot;，这个时候你打开source文件夹你会发现一个about的文件夹，里面会有一个index.md的文件。打开http://localhost:4000/about，这个时候你就会发现你刚才编辑的index.md的内容会出现在这里。 layout 为 page的时候，其实就是相当于生成一个新的路径，也就是我们说的url的path，或者也可以称作路由。通过这种方式，我们可以把我们的博客再进行细分各个内容版块，更有条理的组织我们的博客。 Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： eg1234---title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签 （不适用于分页） categories 分类 （不适用于分页） permalink 覆盖文章网址 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 eg12345categories:- Diarytags:- PS3- Games 如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。 分类Eg1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life] 此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。 标签插件具体内容参考官网 参考链接 hexo 写作","link":"/blogs/articles/writing-hexo/"},{"title":"github-actions入门","text":"GitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。 GitHub Actions 简介GitHub Actions 帮助您自动完成软件开发周期内的任务。 GitHub Actions 是事件驱动的，意味着您可以在指定事件发生后运行一系列命令。 例如，每次有人为仓库创建拉取请求时，您都可以自动运行命令来执行软件测试脚本。 此示意图说明如何使用 GitHub Actions 自动运行软件测试脚本。事件会自动触发其中包作业的工作流程。 然后，作业使用步骤来控制操作运行的顺序。 这些操作是自动化软件测试的命令。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方！ GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName/repoName的语法引用 action。比如，actions/setup-node就表示github.com/actions/setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com/actions 里面。 既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。 actions123actions/setup-node@74bc508 # 指向一个 commitactions/setup-node@v1.0 # 指向一个标签actions/setup-node@master # 指向一个分支 基础概念GitHub Actions 有一些自己的术语。 workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 step（步骤）：每个 job 由多个 step 构成，一步步完成。 action （动作）：每个 step 可以依次执行一个或多个命令（action）。 虚拟环境GitHub 托管的运行器是由安装了 GitHub Actions 运行器应用程序的 GitHub 托管的虚拟机。 GitHub 提供使用 Linux、Windows 和 macOS 操作系统的运行器。 GitHub Ac­tions 为每个任务 (job) 都提供了一个虚拟机来执行，每台虚拟机都有相同的硬件资源： 2 核 CPU 7 GB RAM 内存 14 GB SSD 硬盘空间 虚拟环境 YAML 工作流程标签 Windows Server 2019 windows-latest 或 windows-2019 Ubuntu 20.04 ubuntu-20.04 Ubuntu 18.04 ubuntu-latest 或 ubuntu-18.04 Ubuntu 16.04 ubuntu-16.04 macOS Big Sur 11.0 macos-11.0 macOS Catalina 10.15 macos-latest 或 macos-10.15 注：Ubuntu 20.04 虚拟环境目前仅作为预览提供。 ubuntu-latest YAML 工作流程标签仍使用 Ubuntu 18.04 虚拟环境。 使用限制： 每个workflow的运行时限为 72 小时 每小时可以调用1000次 GitHub API 。 每个 job 最多可以执行6个小时。 免费版的用户最大支持20个 job 并发执行，macOS 最大只支持5个。 私有仓库 Linux 运行器每月累计使用时间为2000分钟，超过后$ 0.008/分钟，公共仓库则无限制。 注： 虽然名称叫持续集成，但当所有任务终止和完成时，虚拟环境内的数据会随之清空，并不会持续。即每个新任务都是一个全新的虚拟环境。 WorkflowGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml or .yaml，比如foo.yml or foo.yaml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml or .yaml文件，就会自动运行该文件。 workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段： name 工作流程的名称。 GitHub 在仓库的操作页面上显示工作流程的名称。 如果省略 name，GitHub 将其设置为相对于仓库根目录的工作流程文件路径。 name1name: GitHub Actions Demo on 必要 触发workflow的 GitHub 事件的名称。 你可以提供单一事件 string、事件的 array、事件 types 的 array 或事件配置 map，以安排工作流程的运行，或将工作流程的执行限于特定文件、标记或分支更改。 有关可用事件的列表，请参阅“触发工作流程的事件” 使用单一事件 Example using a single event1on: push 上面代码指定，push事件触发 workflow。 使用事件列表的示例 Example using a list of events1on: [push, pull_request] 上面代码指定，push事件或pull_request事件都可以触发 workflow。 完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。 on.&lt;push|pull_request&gt;.&lt;tags|branches&gt; 指定触发事件时，可以限定分支或标签。 1234on: push: branches: - master 上面代码指定，只有master分支发生push事件时，才会触发 workflow。 jobs workflow运行包括一项或多项jobs。 jobs默认是并行运行。 要按顺序运行作业，您可以使用 &lt;job_id&gt;needs 关键词在其他job上定义依赖项。 每个作业在 runs-on 指定的运行器环境中运行。 jobs.&lt;job_id&gt;.name workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。 jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。 12345jobs: my_first_job: name: My first job my_second_job: name: My second job 上面代码的jobs字段包含两项任务，job_id分别是my_first_job和my_second_job。 jobs.&lt;job_id&gt;.needs needs字段指定当前任务的依赖关系，即运行顺序。 123456jobs: job1: job2: needs: job1 job3: needs: [job1, job2] 上面代码中，job1必须先于job2完成，而job3等待job1和job2的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。 jobs.&lt;job_id&gt;.runs-on runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。 123- ubuntu-latest，ubuntu-18.04或ubuntu-16.04- windows-latest，windows-2019或windows-2016- macOS-latest或macOS-10.14 下面代码指定虚拟机环境为ubuntu-18.04。 1runs-on: ubuntu-18.04 jobs.&lt;job_id&gt;.steps steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。 123- jobs.&lt;job_id&gt;.steps.name：步骤名称。- jobs.&lt;job_id&gt;.steps.run：该步骤运行的命令或者 action。- jobs.&lt;job_id&gt;.steps.env：该步骤所需的环境变量。 下面是一个完整的 workflow 文件的范例。 workflow12345678910111213141516name: Greeting from Monaon: pushjobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 上面代码中，steps字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。 jobs.&lt;job_id&gt;.steps[*].uses 选择要作为job中step的一部分运行的操作。 操作是一种可重复使用的代码单位。 你可以使用工作流程所在仓库中、公共仓库中或发布 Docker 容器映像中定义的操作。 示例123456789steps: # Reference a specific commit - uses: actions/setup-node@74bc508 # Reference the major version of a release - uses: actions/setup-node@v1 # Reference a minor version of a release - uses: actions/setup-node@v1.2 # Reference a branch - uses: actions/setup-node@main 更多uses使用示例参考官网 示例一个简单的workflow文件示例workflow example123456789101112131415161718192021222324252627name: Hello Worldon: push: branches: - mainjobs: my_first_job: name: My first job runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@main - name: Run a single-line script run: echo &quot;Hello World!&quot; my_second_job: name: My second job runs-on: macos-latest steps: - name: Run a multi-line script env: MY_VAR: Hello World! MY_NAME: P3TERX run: | echo $MY_VAR echo My name is $MY_NAME 上面这个 workflow 文件的要点如下。 整个流程在main分支发生push事件时触发。 有两个个job，一个运行在虚拟机环境ubuntu-latest。一个运行在macos-latest My First Job 第一步是获取源码，使用的 action 是actions/checkout。 第二步是运行一个简单的脚本：echo &quot;Hello World!&quot; My Second Job 设定环境变量 MY_VAR 和MY_NAME 运行脚本打印环境变量 保存上面的文件后，将整个仓库推送到 GitHub。 GitHub 发现了 workflow 文件以后，就会自动运行。你可以在网站上实时查看运行日志，日志默认保存30天。 示例文件运行截图： react 项目发布到Github Pages示例项目需要将构建成果发到 GitHub 仓库，因此需要 GitHub 密钥。按照官方文档，生成一个密钥。然后，将这个密钥储存到当前仓库的Settings/Secrets里面。 在这个仓库的.github/workflows目录，生成一个 workflow 文件，名字可以随便取，这个示例是react-cli.yml。 我们选用一个别人已经写好的 action：JamesIves/github-pages-deploy-action，它提供了 workflow 的范例文件，直接拷贝过来就行了（查看源码） react-cli123456789101112131415161718192021222324name: github-test-actions上的React项目部署到github pageson: push: branches: - react-branchjobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout 🛎️ uses: actions/checkout@v2 with: persist-credentials: false - name: Install and Build 🔧 run: | npm install npm run build - name: Deploy 🚀 uses: JamesIves/github-pages-deploy-action@3.7.1 with: ACCESS_TOKEN: ${{ secrets.REACT_WORKFLOW_TOKEN }} BRANCH: gh-pages # The branch the action should deploy to. FOLDER: build # The folder the action should deploy. 整个流程在react-branch分支发生push事件时触发。 只有一个job，运行在虚拟机环境ubuntu-latest。 第一步是获取源码，使用的 action 是actions/checkout。 第二步是安装与构建。 第三步是部署，使用的 action 是JamesIves/github-pages-deploy-action，使用三个变量，分别为 GitHub 密钥、发布分支、构建成果所在目录。其中，只有 GitHub 密钥是变量，需要写在双括号里面，其他三个都可以直接写在文件里。 保存上面的文件后，将整个仓库推送到 GitHub。 等到 workflow 运行结束，访问 GitHub Page，会看到网页已经部署到指定网址上了。 参考链接 GitHub Actions GitHub Actions 入门教程 GitHub 托管的运行器的规格 GitHub 使用限制、计费和管理 GitHub 操作的工作流程语法 五分钟了解 YAML actions/checkout github-pages-deploy-action","link":"/blogs/articles/start-github-actions/"},{"title":"微信小程序云开发获取用户手机号","text":"在网上搜索时，大部分微信小程序云开发获取手机号码的例子还都是需要通过code获取session_key来解密信息取得手机号码，总感觉哪里不对，官网上都已经说过，云开发是自动鉴权的，不应该还要解密,因此下面介绍如何使用云开发获取用户信息数据。 具体步骤1，页面 cellphone.wxml cellphone.wxml1&lt;button open-type=&quot;getPhoneNumber&quot; bindgetphonenumber=&quot;getPhoneNumber&quot;&gt;&lt;/button&gt; 2，文件cellphone.js cellphone.js12345678910111213141516Page({ getPhoneNumber(e) { console.log(e.detail); wx.cloud .callFunction({ name: &quot;openapi&quot;, data: { action: &quot;getcellphone&quot;, id: e.detail.cloudID } }) .then(res =&gt; { console.log(&quot;res: &quot;, res); }); }}); 3，云函数 openapi 的index.js index.js123456789101112131415161718192021// 云函数入口文件const cloud = require(&quot;wx-server-sdk&quot;);cloud.init();// 云函数入口函数exports.main = async (event, context) =&gt; { switch (event.action) { case &quot;getcellphone&quot;: { return getCellphone(event); } default: { return; } }};async function getCellphone(event) { const res = await cloud.getOpenData({ list: [event.id] }); return { res, event };} 调用后res数据如下 res123456789101112131415161718{ &quot;list&quot;: [ { &quot;cloudID&quot;: &quot;***********&quot;, &quot;data&quot;: { &quot;phoneNumber&quot;: &quot;****&quot;, // 用户绑定的手机号（国外手机号会有区号） &quot;purePhoneNumber&quot;: &quot;******&quot;, // 没有区号的手机号 &quot;countryCode&quot;: &quot;86&quot;, // 区号 &quot;watermark&quot;: { &quot;timestamp&quot;: 1612332238, &quot;appid&quot;: &quot;********&quot; } } } ], &quot;errMsg&quot;: &quot;getOpenData:ok&quot;, &quot;errCode&quot;: 0} 全程不涉及code,session_key和加密解密啥事，即可获取到用户的手机号。 参考链接 微信小程序云开发获取手机号码 获取手机号| 微信开放文档 - 微信开放社区 - 腾讯 Cloud.getOpenData(list: string[]): Object","link":"/blogs/articles/wx-get-cellphone/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/blogs/tags/hexo/"},{"name":"ci","slug":"ci","link":"/blogs/tags/ci/"},{"name":"install","slug":"install","link":"/blogs/tags/install/"},{"name":"rust","slug":"rust","link":"/blogs/tags/rust/"},{"name":"configuration","slug":"configuration","link":"/blogs/tags/configuration/"},{"name":"questions","slug":"questions","link":"/blogs/tags/questions/"},{"name":"SEO","slug":"SEO","link":"/blogs/tags/SEO/"},{"name":"permalinks","slug":"permalinks","link":"/blogs/tags/permalinks/"},{"name":"write","slug":"write","link":"/blogs/tags/write/"},{"name":"github","slug":"github","link":"/blogs/tags/github/"},{"name":"actions","slug":"actions","link":"/blogs/tags/actions/"},{"name":"workflow","slug":"workflow","link":"/blogs/tags/workflow/"},{"name":"微信小程序","slug":"微信小程序","link":"/blogs/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"云开发","slug":"云开发","link":"/blogs/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/blogs/categories/hexo/"},{"name":"install","slug":"install","link":"/blogs/categories/install/"},{"name":"write","slug":"hexo/write","link":"/blogs/categories/hexo/write/"},{"name":"github","slug":"github","link":"/blogs/categories/github/"},{"name":"rust","slug":"install/rust","link":"/blogs/categories/install/rust/"},{"name":"小程序","slug":"小程序","link":"/blogs/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"configuration","slug":"hexo/configuration","link":"/blogs/categories/hexo/configuration/"},{"name":"actions","slug":"github/actions","link":"/blogs/categories/github/actions/"},{"name":"rust","slug":"rust","link":"/blogs/categories/rust/"},{"name":"微信小程序","slug":"小程序/微信小程序","link":"/blogs/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"install","slug":"rust/install","link":"/blogs/categories/rust/install/"}]}